(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
    typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["md3-react"] = {}, global.React));
})(this, (function (exports, React) { 'use strict';

    /**
     * @license
     * Copyright 2021 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // This file is automatically generated. Do not modify it.
    /**
     * Utility methods for mathematical operations.
     */
    /**
     * The signum function.
     *
     * @return 1 if num > 0, -1 if num < 0, and 0 if num = 0
     */
    function signum(num) {
        if (num < 0) {
            return -1;
        }
        else if (num === 0) {
            return 0;
        }
        else {
            return 1;
        }
    }
    /**
     * The linear interpolation function.
     *
     * @return start if amount = 0 and stop if amount = 1
     */
    function lerp(start, stop, amount) {
        return (1.0 - amount) * start + amount * stop;
    }
    /**
     * Clamps an integer between two integers.
     *
     * @return input when min <= input <= max, and either min or max
     * otherwise.
     */
    function clampInt(min, max, input) {
        if (input < min) {
            return min;
        }
        else if (input > max) {
            return max;
        }
        return input;
    }
    /**
     * Clamps an integer between two floating-point numbers.
     *
     * @return input when min <= input <= max, and either min or max
     * otherwise.
     */
    function clampDouble(min, max, input) {
        if (input < min) {
            return min;
        }
        else if (input > max) {
            return max;
        }
        return input;
    }
    /**
     * Sanitizes a degree measure as a floating-point number.
     *
     * @return a degree measure between 0.0 (inclusive) and 360.0
     * (exclusive).
     */
    function sanitizeDegreesDouble(degrees) {
        degrees = degrees % 360.0;
        if (degrees < 0) {
            degrees = degrees + 360.0;
        }
        return degrees;
    }
    /**
     * Sign of direction change needed to travel from one angle to
     * another.
     *
     * For angles that are 180 degrees apart from each other, both
     * directions have the same travel distance, so either direction is
     * shortest. The value 1.0 is returned in this case.
     *
     * @param from The angle travel starts from, in degrees.
     * @param to The angle travel ends at, in degrees.
     * @return -1 if decreasing from leads to the shortest travel
     * distance, 1 if increasing from leads to the shortest travel
     * distance.
     */
    function rotationDirection(from, to) {
        const increasingDifference = sanitizeDegreesDouble(to - from);
        return increasingDifference <= 180.0 ? 1.0 : -1.0;
    }
    /**
     * Distance of two points on a circle, represented using degrees.
     */
    function differenceDegrees(a, b) {
        return 180.0 - Math.abs(Math.abs(a - b) - 180.0);
    }
    /**
     * Multiplies a 1x3 row vector with a 3x3 matrix.
     */
    function matrixMultiply(row, matrix) {
        const a = row[0] * matrix[0][0] + row[1] * matrix[0][1] + row[2] * matrix[0][2];
        const b = row[0] * matrix[1][0] + row[1] * matrix[1][1] + row[2] * matrix[1][2];
        const c = row[0] * matrix[2][0] + row[1] * matrix[2][1] + row[2] * matrix[2][2];
        return [a, b, c];
    }

    /**
     * @license
     * Copyright 2021 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // This file is automatically generated. Do not modify it.
    /**
     * Color science utilities.
     *
     * Utility methods for color science constants and color space
     * conversions that aren't HCT or CAM16.
     */
    const SRGB_TO_XYZ = [
        [0.41233895, 0.35762064, 0.18051042],
        [0.2126, 0.7152, 0.0722],
        [0.01932141, 0.11916382, 0.95034478],
    ];
    const XYZ_TO_SRGB = [
        [
            3.2413774792388685,
            -1.5376652402851851,
            -0.49885366846268053,
        ],
        [
            -0.9691452513005321,
            1.8758853451067872,
            0.04156585616912061,
        ],
        [
            0.05562093689691305,
            -0.20395524564742123,
            1.0571799111220335,
        ],
    ];
    const WHITE_POINT_D65 = [95.047, 100.0, 108.883];
    /**
     * Converts a color from RGB components to ARGB format.
     */
    function argbFromRgb(red, green, blue) {
        return (255 << 24 | (red & 255) << 16 | (green & 255) << 8 | blue & 255) >>>
            0;
    }
    /**
     * Converts a color from linear RGB components to ARGB format.
     */
    function argbFromLinrgb(linrgb) {
        const r = delinearized(linrgb[0]);
        const g = delinearized(linrgb[1]);
        const b = delinearized(linrgb[2]);
        return argbFromRgb(r, g, b);
    }
    /**
     * Returns the alpha component of a color in ARGB format.
     */
    function alphaFromArgb(argb) {
        return argb >> 24 & 255;
    }
    /**
     * Returns the red component of a color in ARGB format.
     */
    function redFromArgb(argb) {
        return argb >> 16 & 255;
    }
    /**
     * Returns the green component of a color in ARGB format.
     */
    function greenFromArgb(argb) {
        return argb >> 8 & 255;
    }
    /**
     * Returns the blue component of a color in ARGB format.
     */
    function blueFromArgb(argb) {
        return argb & 255;
    }
    /**
     * Converts a color from ARGB to XYZ.
     */
    function argbFromXyz(x, y, z) {
        const matrix = XYZ_TO_SRGB;
        const linearR = matrix[0][0] * x + matrix[0][1] * y + matrix[0][2] * z;
        const linearG = matrix[1][0] * x + matrix[1][1] * y + matrix[1][2] * z;
        const linearB = matrix[2][0] * x + matrix[2][1] * y + matrix[2][2] * z;
        const r = delinearized(linearR);
        const g = delinearized(linearG);
        const b = delinearized(linearB);
        return argbFromRgb(r, g, b);
    }
    /**
     * Converts a color from XYZ to ARGB.
     */
    function xyzFromArgb(argb) {
        const r = linearized(redFromArgb(argb));
        const g = linearized(greenFromArgb(argb));
        const b = linearized(blueFromArgb(argb));
        return matrixMultiply([r, g, b], SRGB_TO_XYZ);
    }
    /**
     * Converts an L* value to an ARGB representation.
     *
     * @param lstar L* in L*a*b*
     * @return ARGB representation of grayscale color with lightness
     * matching L*
     */
    function argbFromLstar(lstar) {
        const y = yFromLstar(lstar);
        const component = delinearized(y);
        return argbFromRgb(component, component, component);
    }
    /**
     * Computes the L* value of a color in ARGB representation.
     *
     * @param argb ARGB representation of a color
     * @return L*, from L*a*b*, coordinate of the color
     */
    function lstarFromArgb(argb) {
        const y = xyzFromArgb(argb)[1];
        return 116.0 * labF(y / 100.0) - 16.0;
    }
    /**
     * Converts an L* value to a Y value.
     *
     * L* in L*a*b* and Y in XYZ measure the same quantity, luminance.
     *
     * L* measures perceptual luminance, a linear scale. Y in XYZ
     * measures relative luminance, a logarithmic scale.
     *
     * @param lstar L* in L*a*b*
     * @return Y in XYZ
     */
    function yFromLstar(lstar) {
        return 100.0 * labInvf((lstar + 16.0) / 116.0);
    }
    /**
     * Converts a Y value to an L* value.
     *
     * L* in L*a*b* and Y in XYZ measure the same quantity, luminance.
     *
     * L* measures perceptual luminance, a linear scale. Y in XYZ
     * measures relative luminance, a logarithmic scale.
     *
     * @param y Y in XYZ
     * @return L* in L*a*b*
     */
    function lstarFromY(y) {
        return labF(y / 100.0) * 116.0 - 16.0;
    }
    /**
     * Linearizes an RGB component.
     *
     * @param rgbComponent 0 <= rgb_component <= 255, represents R/G/B
     * channel
     * @return 0.0 <= output <= 100.0, color channel converted to
     * linear RGB space
     */
    function linearized(rgbComponent) {
        const normalized = rgbComponent / 255.0;
        if (normalized <= 0.040449936) {
            return normalized / 12.92 * 100.0;
        }
        else {
            return Math.pow((normalized + 0.055) / 1.055, 2.4) * 100.0;
        }
    }
    /**
     * Delinearizes an RGB component.
     *
     * @param rgbComponent 0.0 <= rgb_component <= 100.0, represents
     * linear R/G/B channel
     * @return 0 <= output <= 255, color channel converted to regular
     * RGB space
     */
    function delinearized(rgbComponent) {
        const normalized = rgbComponent / 100.0;
        let delinearized = 0.0;
        if (normalized <= 0.0031308) {
            delinearized = normalized * 12.92;
        }
        else {
            delinearized = 1.055 * Math.pow(normalized, 1.0 / 2.4) - 0.055;
        }
        return clampInt(0, 255, Math.round(delinearized * 255.0));
    }
    /**
     * Returns the standard white point; white on a sunny day.
     *
     * @return The white point
     */
    function whitePointD65() {
        return WHITE_POINT_D65;
    }
    /**
     * Return RGBA from a given int32 color
     *
     * @param argb ARGB representation of a int32 color.
     * @return RGBA representation of a int32 color.
     */
    function rgbaFromArgb(argb) {
        const r = redFromArgb(argb);
        const g = greenFromArgb(argb);
        const b = blueFromArgb(argb);
        const a = alphaFromArgb(argb);
        return { r, g, b, a };
    }
    function labF(t) {
        const e = 216.0 / 24389.0;
        const kappa = 24389.0 / 27.0;
        if (t > e) {
            return Math.pow(t, 1.0 / 3.0);
        }
        else {
            return (kappa * t + 16) / 116;
        }
    }
    function labInvf(ft) {
        const e = 216.0 / 24389.0;
        const kappa = 24389.0 / 27.0;
        const ft3 = ft * ft * ft;
        if (ft3 > e) {
            return ft3;
        }
        else {
            return (116 * ft - 16) / kappa;
        }
    }

    /**
     * @license
     * Copyright 2021 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * In traditional color spaces, a color can be identified solely by the
     * observer's measurement of the color. Color appearance models such as CAM16
     * also use information about the environment where the color was
     * observed, known as the viewing conditions.
     *
     * For example, white under the traditional assumption of a midday sun white
     * point is accurately measured as a slightly chromatic blue by CAM16. (roughly,
     * hue 203, chroma 3, lightness 100)
     *
     * This class caches intermediate values of the CAM16 conversion process that
     * depend only on viewing conditions, enabling speed ups.
     */
    class ViewingConditions {
        /**
         * Create ViewingConditions from a simple, physically relevant, set of
         * parameters.
         *
         * @param whitePoint White point, measured in the XYZ color space.
         *     default = D65, or sunny day afternoon
         * @param adaptingLuminance The luminance of the adapting field. Informally,
         *     how bright it is in the room where the color is viewed. Can be
         *     calculated from lux by multiplying lux by 0.0586. default = 11.72,
         *     or 200 lux.
         * @param backgroundLstar The lightness of the area surrounding the color.
         *     measured by L* in L*a*b*. default = 50.0
         * @param surround A general description of the lighting surrounding the
         *     color. 0 is pitch dark, like watching a movie in a theater. 1.0 is a
         *     dimly light room, like watching TV at home at night. 2.0 means there
         *     is no difference between the lighting on the color and around it.
         *     default = 2.0
         * @param discountingIlluminant Whether the eye accounts for the tint of the
         *     ambient lighting, such as knowing an apple is still red in green light.
         *     default = false, the eye does not perform this process on
         *       self-luminous objects like displays.
         */
        static make(whitePoint = whitePointD65(), adaptingLuminance = (200.0 / Math.PI) * yFromLstar(50.0) / 100.0, backgroundLstar = 50.0, surround = 2.0, discountingIlluminant = false) {
            const xyz = whitePoint;
            const rW = xyz[0] * 0.401288 + xyz[1] * 0.650173 + xyz[2] * -0.051461;
            const gW = xyz[0] * -0.250268 + xyz[1] * 1.204414 + xyz[2] * 0.045854;
            const bW = xyz[0] * -0.002079 + xyz[1] * 0.048952 + xyz[2] * 0.953127;
            const f = 0.8 + surround / 10.0;
            const c = f >= 0.9 ? lerp(0.59, 0.69, (f - 0.9) * 10.0) :
                lerp(0.525, 0.59, (f - 0.8) * 10.0);
            let d = discountingIlluminant ?
                1.0 :
                f * (1.0 - (1.0 / 3.6) * Math.exp((-adaptingLuminance - 42.0) / 92.0));
            d = d > 1.0 ? 1.0 : d < 0.0 ? 0.0 : d;
            const nc = f;
            const rgbD = [
                d * (100.0 / rW) + 1.0 - d,
                d * (100.0 / gW) + 1.0 - d,
                d * (100.0 / bW) + 1.0 - d,
            ];
            const k = 1.0 / (5.0 * adaptingLuminance + 1.0);
            const k4 = k * k * k * k;
            const k4F = 1.0 - k4;
            const fl = k4 * adaptingLuminance +
                0.1 * k4F * k4F * Math.cbrt(5.0 * adaptingLuminance);
            const n = yFromLstar(backgroundLstar) / whitePoint[1];
            const z = 1.48 + Math.sqrt(n);
            const nbb = 0.725 / Math.pow(n, 0.2);
            const ncb = nbb;
            const rgbAFactors = [
                Math.pow((fl * rgbD[0] * rW) / 100.0, 0.42),
                Math.pow((fl * rgbD[1] * gW) / 100.0, 0.42),
                Math.pow((fl * rgbD[2] * bW) / 100.0, 0.42),
            ];
            const rgbA = [
                (400.0 * rgbAFactors[0]) / (rgbAFactors[0] + 27.13),
                (400.0 * rgbAFactors[1]) / (rgbAFactors[1] + 27.13),
                (400.0 * rgbAFactors[2]) / (rgbAFactors[2] + 27.13),
            ];
            const aw = (2.0 * rgbA[0] + rgbA[1] + 0.05 * rgbA[2]) * nbb;
            return new ViewingConditions(n, aw, nbb, ncb, c, nc, rgbD, fl, Math.pow(fl, 0.25), z);
        }
        /**
         * Parameters are intermediate values of the CAM16 conversion process. Their
         * names are shorthand for technical color science terminology, this class
         * would not benefit from documenting them individually. A brief overview
         * is available in the CAM16 specification, and a complete overview requires
         * a color science textbook, such as Fairchild's Color Appearance Models.
         */
        constructor(n, aw, nbb, ncb, c, nc, rgbD, fl, fLRoot, z) {
            this.n = n;
            this.aw = aw;
            this.nbb = nbb;
            this.ncb = ncb;
            this.c = c;
            this.nc = nc;
            this.rgbD = rgbD;
            this.fl = fl;
            this.fLRoot = fLRoot;
            this.z = z;
        }
    }
    /** sRGB-like viewing conditions.  */
    ViewingConditions.DEFAULT = ViewingConditions.make();

    /**
     * @license
     * Copyright 2021 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * CAM16, a color appearance model. Colors are not just defined by their hex
     * code, but rather, a hex code and viewing conditions.
     *
     * CAM16 instances also have coordinates in the CAM16-UCS space, called J*, a*,
     * b*, or jstar, astar, bstar in code. CAM16-UCS is included in the CAM16
     * specification, and should be used when measuring distances between colors.
     *
     * In traditional color spaces, a color can be identified solely by the
     * observer's measurement of the color. Color appearance models such as CAM16
     * also use information about the environment where the color was
     * observed, known as the viewing conditions.
     *
     * For example, white under the traditional assumption of a midday sun white
     * point is accurately measured as a slightly chromatic blue by CAM16. (roughly,
     * hue 203, chroma 3, lightness 100)
     */
    class Cam16 {
        /**
         * All of the CAM16 dimensions can be calculated from 3 of the dimensions, in
         * the following combinations:
         *      -  {j or q} and {c, m, or s} and hue
         *      - jstar, astar, bstar
         * Prefer using a static method that constructs from 3 of those dimensions.
         * This constructor is intended for those methods to use to return all
         * possible dimensions.
         *
         * @param hue
         * @param chroma informally, colorfulness / color intensity. like saturation
         *     in HSL, except perceptually accurate.
         * @param j lightness
         * @param q brightness; ratio of lightness to white point's lightness
         * @param m colorfulness
         * @param s saturation; ratio of chroma to white point's chroma
         * @param jstar CAM16-UCS J coordinate
         * @param astar CAM16-UCS a coordinate
         * @param bstar CAM16-UCS b coordinate
         */
        constructor(hue, chroma, j, q, m, s, jstar, astar, bstar) {
            this.hue = hue;
            this.chroma = chroma;
            this.j = j;
            this.q = q;
            this.m = m;
            this.s = s;
            this.jstar = jstar;
            this.astar = astar;
            this.bstar = bstar;
        }
        /**
         * CAM16 instances also have coordinates in the CAM16-UCS space, called J*,
         * a*, b*, or jstar, astar, bstar in code. CAM16-UCS is included in the CAM16
         * specification, and is used to measure distances between colors.
         */
        distance(other) {
            const dJ = this.jstar - other.jstar;
            const dA = this.astar - other.astar;
            const dB = this.bstar - other.bstar;
            const dEPrime = Math.sqrt(dJ * dJ + dA * dA + dB * dB);
            const dE = 1.41 * Math.pow(dEPrime, 0.63);
            return dE;
        }
        /**
         * @param argb ARGB representation of a color.
         * @return CAM16 color, assuming the color was viewed in default viewing
         *     conditions.
         */
        static fromInt(argb) {
            return Cam16.fromIntInViewingConditions(argb, ViewingConditions.DEFAULT);
        }
        /**
         * @param argb ARGB representation of a color.
         * @param viewingConditions Information about the environment where the color
         *     was observed.
         * @return CAM16 color.
         */
        static fromIntInViewingConditions(argb, viewingConditions) {
            const red = (argb & 0x00ff0000) >> 16;
            const green = (argb & 0x0000ff00) >> 8;
            const blue = (argb & 0x000000ff);
            const redL = linearized(red);
            const greenL = linearized(green);
            const blueL = linearized(blue);
            const x = 0.41233895 * redL + 0.35762064 * greenL + 0.18051042 * blueL;
            const y = 0.2126 * redL + 0.7152 * greenL + 0.0722 * blueL;
            const z = 0.01932141 * redL + 0.11916382 * greenL + 0.95034478 * blueL;
            const rC = 0.401288 * x + 0.650173 * y - 0.051461 * z;
            const gC = -0.250268 * x + 1.204414 * y + 0.045854 * z;
            const bC = -0.002079 * x + 0.048952 * y + 0.953127 * z;
            const rD = viewingConditions.rgbD[0] * rC;
            const gD = viewingConditions.rgbD[1] * gC;
            const bD = viewingConditions.rgbD[2] * bC;
            const rAF = Math.pow((viewingConditions.fl * Math.abs(rD)) / 100.0, 0.42);
            const gAF = Math.pow((viewingConditions.fl * Math.abs(gD)) / 100.0, 0.42);
            const bAF = Math.pow((viewingConditions.fl * Math.abs(bD)) / 100.0, 0.42);
            const rA = (signum(rD) * 400.0 * rAF) / (rAF + 27.13);
            const gA = (signum(gD) * 400.0 * gAF) / (gAF + 27.13);
            const bA = (signum(bD) * 400.0 * bAF) / (bAF + 27.13);
            const a = (11.0 * rA + -12.0 * gA + bA) / 11.0;
            const b = (rA + gA - 2.0 * bA) / 9.0;
            const u = (20.0 * rA + 20.0 * gA + 21.0 * bA) / 20.0;
            const p2 = (40.0 * rA + 20.0 * gA + bA) / 20.0;
            const atan2 = Math.atan2(b, a);
            const atanDegrees = (atan2 * 180.0) / Math.PI;
            const hue = atanDegrees < 0 ? atanDegrees + 360.0 :
                atanDegrees >= 360 ? atanDegrees - 360.0 :
                    atanDegrees;
            const hueRadians = (hue * Math.PI) / 180.0;
            const ac = p2 * viewingConditions.nbb;
            const j = 100.0 *
                Math.pow(ac / viewingConditions.aw, viewingConditions.c * viewingConditions.z);
            const q = (4.0 / viewingConditions.c) * Math.sqrt(j / 100.0) *
                (viewingConditions.aw + 4.0) * viewingConditions.fLRoot;
            const huePrime = hue < 20.14 ? hue + 360 : hue;
            const eHue = 0.25 * (Math.cos((huePrime * Math.PI) / 180.0 + 2.0) + 3.8);
            const p1 = (50000.0 / 13.0) * eHue * viewingConditions.nc * viewingConditions.ncb;
            const t = (p1 * Math.sqrt(a * a + b * b)) / (u + 0.305);
            const alpha = Math.pow(t, 0.9) *
                Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73);
            const c = alpha * Math.sqrt(j / 100.0);
            const m = c * viewingConditions.fLRoot;
            const s = 50.0 *
                Math.sqrt((alpha * viewingConditions.c) / (viewingConditions.aw + 4.0));
            const jstar = ((1.0 + 100.0 * 0.007) * j) / (1.0 + 0.007 * j);
            const mstar = (1.0 / 0.0228) * Math.log(1.0 + 0.0228 * m);
            const astar = mstar * Math.cos(hueRadians);
            const bstar = mstar * Math.sin(hueRadians);
            return new Cam16(hue, c, j, q, m, s, jstar, astar, bstar);
        }
        /**
         * @param j CAM16 lightness
         * @param c CAM16 chroma
         * @param h CAM16 hue
         */
        static fromJch(j, c, h) {
            return Cam16.fromJchInViewingConditions(j, c, h, ViewingConditions.DEFAULT);
        }
        /**
         * @param j CAM16 lightness
         * @param c CAM16 chroma
         * @param h CAM16 hue
         * @param viewingConditions Information about the environment where the color
         *     was observed.
         */
        static fromJchInViewingConditions(j, c, h, viewingConditions) {
            const q = (4.0 / viewingConditions.c) * Math.sqrt(j / 100.0) *
                (viewingConditions.aw + 4.0) * viewingConditions.fLRoot;
            const m = c * viewingConditions.fLRoot;
            const alpha = c / Math.sqrt(j / 100.0);
            const s = 50.0 *
                Math.sqrt((alpha * viewingConditions.c) / (viewingConditions.aw + 4.0));
            const hueRadians = (h * Math.PI) / 180.0;
            const jstar = ((1.0 + 100.0 * 0.007) * j) / (1.0 + 0.007 * j);
            const mstar = (1.0 / 0.0228) * Math.log(1.0 + 0.0228 * m);
            const astar = mstar * Math.cos(hueRadians);
            const bstar = mstar * Math.sin(hueRadians);
            return new Cam16(h, c, j, q, m, s, jstar, astar, bstar);
        }
        /**
         * @param jstar CAM16-UCS lightness.
         * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
         *     coordinate on the Y axis.
         * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
         *     coordinate on the X axis.
         */
        static fromUcs(jstar, astar, bstar) {
            return Cam16.fromUcsInViewingConditions(jstar, astar, bstar, ViewingConditions.DEFAULT);
        }
        /**
         * @param jstar CAM16-UCS lightness.
         * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
         *     coordinate on the Y axis.
         * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
         *     coordinate on the X axis.
         * @param viewingConditions Information about the environment where the color
         *     was observed.
         */
        static fromUcsInViewingConditions(jstar, astar, bstar, viewingConditions) {
            const a = astar;
            const b = bstar;
            const m = Math.sqrt(a * a + b * b);
            const M = (Math.exp(m * 0.0228) - 1.0) / 0.0228;
            const c = M / viewingConditions.fLRoot;
            let h = Math.atan2(b, a) * (180.0 / Math.PI);
            if (h < 0.0) {
                h += 360.0;
            }
            const j = jstar / (1 - (jstar - 100) * 0.007);
            return Cam16.fromJchInViewingConditions(j, c, h, viewingConditions);
        }
        /**
         *  @return ARGB representation of color, assuming the color was viewed in
         *     default viewing conditions, which are near-identical to the default
         *     viewing conditions for sRGB.
         */
        toInt() {
            return this.viewed(ViewingConditions.DEFAULT);
        }
        /**
         * @param viewingConditions Information about the environment where the color
         *     will be viewed.
         * @return ARGB representation of color
         */
        viewed(viewingConditions) {
            const alpha = this.chroma === 0.0 || this.j === 0.0 ?
                0.0 :
                this.chroma / Math.sqrt(this.j / 100.0);
            const t = Math.pow(alpha / Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73), 1.0 / 0.9);
            const hRad = (this.hue * Math.PI) / 180.0;
            const eHue = 0.25 * (Math.cos(hRad + 2.0) + 3.8);
            const ac = viewingConditions.aw *
                Math.pow(this.j / 100.0, 1.0 / viewingConditions.c / viewingConditions.z);
            const p1 = eHue * (50000.0 / 13.0) * viewingConditions.nc * viewingConditions.ncb;
            const p2 = ac / viewingConditions.nbb;
            const hSin = Math.sin(hRad);
            const hCos = Math.cos(hRad);
            const gamma = (23.0 * (p2 + 0.305) * t) /
                (23.0 * p1 + 11.0 * t * hCos + 108.0 * t * hSin);
            const a = gamma * hCos;
            const b = gamma * hSin;
            const rA = (460.0 * p2 + 451.0 * a + 288.0 * b) / 1403.0;
            const gA = (460.0 * p2 - 891.0 * a - 261.0 * b) / 1403.0;
            const bA = (460.0 * p2 - 220.0 * a - 6300.0 * b) / 1403.0;
            const rCBase = Math.max(0, (27.13 * Math.abs(rA)) / (400.0 - Math.abs(rA)));
            const rC = signum(rA) * (100.0 / viewingConditions.fl) *
                Math.pow(rCBase, 1.0 / 0.42);
            const gCBase = Math.max(0, (27.13 * Math.abs(gA)) / (400.0 - Math.abs(gA)));
            const gC = signum(gA) * (100.0 / viewingConditions.fl) *
                Math.pow(gCBase, 1.0 / 0.42);
            const bCBase = Math.max(0, (27.13 * Math.abs(bA)) / (400.0 - Math.abs(bA)));
            const bC = signum(bA) * (100.0 / viewingConditions.fl) *
                Math.pow(bCBase, 1.0 / 0.42);
            const rF = rC / viewingConditions.rgbD[0];
            const gF = gC / viewingConditions.rgbD[1];
            const bF = bC / viewingConditions.rgbD[2];
            const x = 1.86206786 * rF - 1.01125463 * gF + 0.14918677 * bF;
            const y = 0.38752654 * rF + 0.62144744 * gF - 0.00897398 * bF;
            const z = -0.01584150 * rF - 0.03412294 * gF + 1.04996444 * bF;
            const argb = argbFromXyz(x, y, z);
            return argb;
        }
        /// Given color expressed in XYZ and viewed in [viewingConditions], convert to
        /// CAM16.
        static fromXyzInViewingConditions(x, y, z, viewingConditions) {
            // Transform XYZ to 'cone'/'rgb' responses
            const rC = 0.401288 * x + 0.650173 * y - 0.051461 * z;
            const gC = -0.250268 * x + 1.204414 * y + 0.045854 * z;
            const bC = -0.002079 * x + 0.048952 * y + 0.953127 * z;
            // Discount illuminant
            const rD = viewingConditions.rgbD[0] * rC;
            const gD = viewingConditions.rgbD[1] * gC;
            const bD = viewingConditions.rgbD[2] * bC;
            // chromatic adaptation
            const rAF = Math.pow(viewingConditions.fl * Math.abs(rD) / 100.0, 0.42);
            const gAF = Math.pow(viewingConditions.fl * Math.abs(gD) / 100.0, 0.42);
            const bAF = Math.pow(viewingConditions.fl * Math.abs(bD) / 100.0, 0.42);
            const rA = signum(rD) * 400.0 * rAF / (rAF + 27.13);
            const gA = signum(gD) * 400.0 * gAF / (gAF + 27.13);
            const bA = signum(bD) * 400.0 * bAF / (bAF + 27.13);
            // redness-greenness
            const a = (11.0 * rA + -12.0 * gA + bA) / 11.0;
            // yellowness-blueness
            const b = (rA + gA - 2.0 * bA) / 9.0;
            // auxiliary components
            const u = (20.0 * rA + 20.0 * gA + 21.0 * bA) / 20.0;
            const p2 = (40.0 * rA + 20.0 * gA + bA) / 20.0;
            // hue
            const atan2 = Math.atan2(b, a);
            const atanDegrees = atan2 * 180.0 / Math.PI;
            const hue = atanDegrees < 0 ? atanDegrees + 360.0 :
                atanDegrees >= 360 ? atanDegrees - 360 :
                    atanDegrees;
            const hueRadians = hue * Math.PI / 180.0;
            // achromatic response to color
            const ac = p2 * viewingConditions.nbb;
            // CAM16 lightness and brightness
            const J = 100.0 *
                Math.pow(ac / viewingConditions.aw, viewingConditions.c * viewingConditions.z);
            const Q = (4.0 / viewingConditions.c) * Math.sqrt(J / 100.0) *
                (viewingConditions.aw + 4.0) * (viewingConditions.fLRoot);
            const huePrime = (hue < 20.14) ? hue + 360 : hue;
            const eHue = (1.0 / 4.0) * (Math.cos(huePrime * Math.PI / 180.0 + 2.0) + 3.8);
            const p1 = 50000.0 / 13.0 * eHue * viewingConditions.nc * viewingConditions.ncb;
            const t = p1 * Math.sqrt(a * a + b * b) / (u + 0.305);
            const alpha = Math.pow(t, 0.9) *
                Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73);
            // CAM16 chroma, colorfulness, chroma
            const C = alpha * Math.sqrt(J / 100.0);
            const M = C * viewingConditions.fLRoot;
            const s = 50.0 *
                Math.sqrt((alpha * viewingConditions.c) / (viewingConditions.aw + 4.0));
            // CAM16-UCS components
            const jstar = (1.0 + 100.0 * 0.007) * J / (1.0 + 0.007 * J);
            const mstar = Math.log(1.0 + 0.0228 * M) / 0.0228;
            const astar = mstar * Math.cos(hueRadians);
            const bstar = mstar * Math.sin(hueRadians);
            return new Cam16(hue, C, J, Q, M, s, jstar, astar, bstar);
        }
        /// XYZ representation of CAM16 seen in [viewingConditions].
        xyzInViewingConditions(viewingConditions) {
            const alpha = (this.chroma === 0.0 || this.j === 0.0) ?
                0.0 :
                this.chroma / Math.sqrt(this.j / 100.0);
            const t = Math.pow(alpha / Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73), 1.0 / 0.9);
            const hRad = this.hue * Math.PI / 180.0;
            const eHue = 0.25 * (Math.cos(hRad + 2.0) + 3.8);
            const ac = viewingConditions.aw *
                Math.pow(this.j / 100.0, 1.0 / viewingConditions.c / viewingConditions.z);
            const p1 = eHue * (50000.0 / 13.0) * viewingConditions.nc * viewingConditions.ncb;
            const p2 = (ac / viewingConditions.nbb);
            const hSin = Math.sin(hRad);
            const hCos = Math.cos(hRad);
            const gamma = 23.0 * (p2 + 0.305) * t /
                (23.0 * p1 + 11 * t * hCos + 108.0 * t * hSin);
            const a = gamma * hCos;
            const b = gamma * hSin;
            const rA = (460.0 * p2 + 451.0 * a + 288.0 * b) / 1403.0;
            const gA = (460.0 * p2 - 891.0 * a - 261.0 * b) / 1403.0;
            const bA = (460.0 * p2 - 220.0 * a - 6300.0 * b) / 1403.0;
            const rCBase = Math.max(0, (27.13 * Math.abs(rA)) / (400.0 - Math.abs(rA)));
            const rC = signum(rA) * (100.0 / viewingConditions.fl) *
                Math.pow(rCBase, 1.0 / 0.42);
            const gCBase = Math.max(0, (27.13 * Math.abs(gA)) / (400.0 - Math.abs(gA)));
            const gC = signum(gA) * (100.0 / viewingConditions.fl) *
                Math.pow(gCBase, 1.0 / 0.42);
            const bCBase = Math.max(0, (27.13 * Math.abs(bA)) / (400.0 - Math.abs(bA)));
            const bC = signum(bA) * (100.0 / viewingConditions.fl) *
                Math.pow(bCBase, 1.0 / 0.42);
            const rF = rC / viewingConditions.rgbD[0];
            const gF = gC / viewingConditions.rgbD[1];
            const bF = bC / viewingConditions.rgbD[2];
            const x = 1.86206786 * rF - 1.01125463 * gF + 0.14918677 * bF;
            const y = 0.38752654 * rF + 0.62144744 * gF - 0.00897398 * bF;
            const z = -0.01584150 * rF - 0.03412294 * gF + 1.04996444 * bF;
            return [x, y, z];
        }
    }

    /**
     * @license
     * Copyright 2021 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // This file is automatically generated. Do not modify it.
    // material_color_utilities is designed to have a consistent API across
    // platforms and modular components that can be moved around easily. Using a
    // class as a namespace facilitates this.
    //
    // tslint:disable:class-as-namespace
    /**
     * A class that solves the HCT equation.
     */
    class HctSolver {
        /**
         * Sanitizes a small enough angle in radians.
         *
         * @param angle An angle in radians; must not deviate too much
         * from 0.
         * @return A coterminal angle between 0 and 2pi.
         */
        static sanitizeRadians(angle) {
            return (angle + Math.PI * 8) % (Math.PI * 2);
        }
        /**
         * Delinearizes an RGB component, returning a floating-point
         * number.
         *
         * @param rgbComponent 0.0 <= rgb_component <= 100.0, represents
         * linear R/G/B channel
         * @return 0.0 <= output <= 255.0, color channel converted to
         * regular RGB space
         */
        static trueDelinearized(rgbComponent) {
            const normalized = rgbComponent / 100.0;
            let delinearized = 0.0;
            if (normalized <= 0.0031308) {
                delinearized = normalized * 12.92;
            }
            else {
                delinearized = 1.055 * Math.pow(normalized, 1.0 / 2.4) - 0.055;
            }
            return delinearized * 255.0;
        }
        static chromaticAdaptation(component) {
            const af = Math.pow(Math.abs(component), 0.42);
            return signum(component) * 400.0 * af / (af + 27.13);
        }
        /**
         * Returns the hue of a linear RGB color in CAM16.
         *
         * @param linrgb The linear RGB coordinates of a color.
         * @return The hue of the color in CAM16, in radians.
         */
        static hueOf(linrgb) {
            const scaledDiscount = matrixMultiply(linrgb, HctSolver.SCALED_DISCOUNT_FROM_LINRGB);
            const rA = HctSolver.chromaticAdaptation(scaledDiscount[0]);
            const gA = HctSolver.chromaticAdaptation(scaledDiscount[1]);
            const bA = HctSolver.chromaticAdaptation(scaledDiscount[2]);
            // redness-greenness
            const a = (11.0 * rA + -12.0 * gA + bA) / 11.0;
            // yellowness-blueness
            const b = (rA + gA - 2.0 * bA) / 9.0;
            return Math.atan2(b, a);
        }
        static areInCyclicOrder(a, b, c) {
            const deltaAB = HctSolver.sanitizeRadians(b - a);
            const deltaAC = HctSolver.sanitizeRadians(c - a);
            return deltaAB < deltaAC;
        }
        /**
         * Solves the lerp equation.
         *
         * @param source The starting number.
         * @param mid The number in the middle.
         * @param target The ending number.
         * @return A number t such that lerp(source, target, t) = mid.
         */
        static intercept(source, mid, target) {
            return (mid - source) / (target - source);
        }
        static lerpPoint(source, t, target) {
            return [
                source[0] + (target[0] - source[0]) * t,
                source[1] + (target[1] - source[1]) * t,
                source[2] + (target[2] - source[2]) * t,
            ];
        }
        /**
         * Intersects a segment with a plane.
         *
         * @param source The coordinates of point A.
         * @param coordinate The R-, G-, or B-coordinate of the plane.
         * @param target The coordinates of point B.
         * @param axis The axis the plane is perpendicular with. (0: R, 1:
         * G, 2: B)
         * @return The intersection point of the segment AB with the plane
         * R=coordinate, G=coordinate, or B=coordinate
         */
        static setCoordinate(source, coordinate, target, axis) {
            const t = HctSolver.intercept(source[axis], coordinate, target[axis]);
            return HctSolver.lerpPoint(source, t, target);
        }
        static isBounded(x) {
            return 0.0 <= x && x <= 100.0;
        }
        /**
         * Returns the nth possible vertex of the polygonal intersection.
         *
         * @param y The Y value of the plane.
         * @param n The zero-based index of the point. 0 <= n <= 11.
         * @return The nth possible vertex of the polygonal intersection
         * of the y plane and the RGB cube, in linear RGB coordinates, if
         * it exists. If this possible vertex lies outside of the cube,
         * [-1.0, -1.0, -1.0] is returned.
         */
        static nthVertex(y, n) {
            const kR = HctSolver.Y_FROM_LINRGB[0];
            const kG = HctSolver.Y_FROM_LINRGB[1];
            const kB = HctSolver.Y_FROM_LINRGB[2];
            const coordA = n % 4 <= 1 ? 0.0 : 100.0;
            const coordB = n % 2 === 0 ? 0.0 : 100.0;
            if (n < 4) {
                const g = coordA;
                const b = coordB;
                const r = (y - g * kG - b * kB) / kR;
                if (HctSolver.isBounded(r)) {
                    return [r, g, b];
                }
                else {
                    return [-1.0, -1.0, -1.0];
                }
            }
            else if (n < 8) {
                const b = coordA;
                const r = coordB;
                const g = (y - r * kR - b * kB) / kG;
                if (HctSolver.isBounded(g)) {
                    return [r, g, b];
                }
                else {
                    return [-1.0, -1.0, -1.0];
                }
            }
            else {
                const r = coordA;
                const g = coordB;
                const b = (y - r * kR - g * kG) / kB;
                if (HctSolver.isBounded(b)) {
                    return [r, g, b];
                }
                else {
                    return [-1.0, -1.0, -1.0];
                }
            }
        }
        /**
         * Finds the segment containing the desired color.
         *
         * @param y The Y value of the color.
         * @param targetHue The hue of the color.
         * @return A list of two sets of linear RGB coordinates, each
         * corresponding to an endpoint of the segment containing the
         * desired color.
         */
        static bisectToSegment(y, targetHue) {
            let left = [-1.0, -1.0, -1.0];
            let right = left;
            let leftHue = 0.0;
            let rightHue = 0.0;
            let initialized = false;
            let uncut = true;
            for (let n = 0; n < 12; n++) {
                const mid = HctSolver.nthVertex(y, n);
                if (mid[0] < 0) {
                    continue;
                }
                const midHue = HctSolver.hueOf(mid);
                if (!initialized) {
                    left = mid;
                    right = mid;
                    leftHue = midHue;
                    rightHue = midHue;
                    initialized = true;
                    continue;
                }
                if (uncut || HctSolver.areInCyclicOrder(leftHue, midHue, rightHue)) {
                    uncut = false;
                    if (HctSolver.areInCyclicOrder(leftHue, targetHue, midHue)) {
                        right = mid;
                        rightHue = midHue;
                    }
                    else {
                        left = mid;
                        leftHue = midHue;
                    }
                }
            }
            return [left, right];
        }
        static midpoint(a, b) {
            return [
                (a[0] + b[0]) / 2,
                (a[1] + b[1]) / 2,
                (a[2] + b[2]) / 2,
            ];
        }
        static criticalPlaneBelow(x) {
            return Math.floor(x - 0.5);
        }
        static criticalPlaneAbove(x) {
            return Math.ceil(x - 0.5);
        }
        /**
         * Finds a color with the given Y and hue on the boundary of the
         * cube.
         *
         * @param y The Y value of the color.
         * @param targetHue The hue of the color.
         * @return The desired color, in linear RGB coordinates.
         */
        static bisectToLimit(y, targetHue) {
            const segment = HctSolver.bisectToSegment(y, targetHue);
            let left = segment[0];
            let leftHue = HctSolver.hueOf(left);
            let right = segment[1];
            for (let axis = 0; axis < 3; axis++) {
                if (left[axis] !== right[axis]) {
                    let lPlane = -1;
                    let rPlane = 255;
                    if (left[axis] < right[axis]) {
                        lPlane = HctSolver.criticalPlaneBelow(HctSolver.trueDelinearized(left[axis]));
                        rPlane = HctSolver.criticalPlaneAbove(HctSolver.trueDelinearized(right[axis]));
                    }
                    else {
                        lPlane = HctSolver.criticalPlaneAbove(HctSolver.trueDelinearized(left[axis]));
                        rPlane = HctSolver.criticalPlaneBelow(HctSolver.trueDelinearized(right[axis]));
                    }
                    for (let i = 0; i < 8; i++) {
                        if (Math.abs(rPlane - lPlane) <= 1) {
                            break;
                        }
                        else {
                            const mPlane = Math.floor((lPlane + rPlane) / 2.0);
                            const midPlaneCoordinate = HctSolver.CRITICAL_PLANES[mPlane];
                            const mid = HctSolver.setCoordinate(left, midPlaneCoordinate, right, axis);
                            const midHue = HctSolver.hueOf(mid);
                            if (HctSolver.areInCyclicOrder(leftHue, targetHue, midHue)) {
                                right = mid;
                                rPlane = mPlane;
                            }
                            else {
                                left = mid;
                                leftHue = midHue;
                                lPlane = mPlane;
                            }
                        }
                    }
                }
            }
            return HctSolver.midpoint(left, right);
        }
        static inverseChromaticAdaptation(adapted) {
            const adaptedAbs = Math.abs(adapted);
            const base = Math.max(0, 27.13 * adaptedAbs / (400.0 - adaptedAbs));
            return signum(adapted) * Math.pow(base, 1.0 / 0.42);
        }
        /**
         * Finds a color with the given hue, chroma, and Y.
         *
         * @param hueRadians The desired hue in radians.
         * @param chroma The desired chroma.
         * @param y The desired Y.
         * @return The desired color as a hexadecimal integer, if found; 0
         * otherwise.
         */
        static findResultByJ(hueRadians, chroma, y) {
            // Initial estimate of j.
            let j = Math.sqrt(y) * 11.0;
            // ===========================================================
            // Operations inlined from Cam16 to avoid repeated calculation
            // ===========================================================
            const viewingConditions = ViewingConditions.DEFAULT;
            const tInnerCoeff = 1 / Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73);
            const eHue = 0.25 * (Math.cos(hueRadians + 2.0) + 3.8);
            const p1 = eHue * (50000.0 / 13.0) * viewingConditions.nc * viewingConditions.ncb;
            const hSin = Math.sin(hueRadians);
            const hCos = Math.cos(hueRadians);
            for (let iterationRound = 0; iterationRound < 5; iterationRound++) {
                // ===========================================================
                // Operations inlined from Cam16 to avoid repeated calculation
                // ===========================================================
                const jNormalized = j / 100.0;
                const alpha = chroma === 0.0 || j === 0.0 ? 0.0 : chroma / Math.sqrt(jNormalized);
                const t = Math.pow(alpha * tInnerCoeff, 1.0 / 0.9);
                const ac = viewingConditions.aw *
                    Math.pow(jNormalized, 1.0 / viewingConditions.c / viewingConditions.z);
                const p2 = ac / viewingConditions.nbb;
                const gamma = 23.0 * (p2 + 0.305) * t /
                    (23.0 * p1 + 11 * t * hCos + 108.0 * t * hSin);
                const a = gamma * hCos;
                const b = gamma * hSin;
                const rA = (460.0 * p2 + 451.0 * a + 288.0 * b) / 1403.0;
                const gA = (460.0 * p2 - 891.0 * a - 261.0 * b) / 1403.0;
                const bA = (460.0 * p2 - 220.0 * a - 6300.0 * b) / 1403.0;
                const rCScaled = HctSolver.inverseChromaticAdaptation(rA);
                const gCScaled = HctSolver.inverseChromaticAdaptation(gA);
                const bCScaled = HctSolver.inverseChromaticAdaptation(bA);
                const linrgb = matrixMultiply([rCScaled, gCScaled, bCScaled], HctSolver.LINRGB_FROM_SCALED_DISCOUNT);
                // ===========================================================
                // Operations inlined from Cam16 to avoid repeated calculation
                // ===========================================================
                if (linrgb[0] < 0 || linrgb[1] < 0 || linrgb[2] < 0) {
                    return 0;
                }
                const kR = HctSolver.Y_FROM_LINRGB[0];
                const kG = HctSolver.Y_FROM_LINRGB[1];
                const kB = HctSolver.Y_FROM_LINRGB[2];
                const fnj = kR * linrgb[0] + kG * linrgb[1] + kB * linrgb[2];
                if (fnj <= 0) {
                    return 0;
                }
                if (iterationRound === 4 || Math.abs(fnj - y) < 0.002) {
                    if (linrgb[0] > 100.01 || linrgb[1] > 100.01 || linrgb[2] > 100.01) {
                        return 0;
                    }
                    return argbFromLinrgb(linrgb);
                }
                // Iterates with Newton method,
                // Using 2 * fn(j) / j as the approximation of fn'(j)
                j = j - (fnj - y) * j / (2 * fnj);
            }
            return 0;
        }
        /**
         * Finds an sRGB color with the given hue, chroma, and L*, if
         * possible.
         *
         * @param hueDegrees The desired hue, in degrees.
         * @param chroma The desired chroma.
         * @param lstar The desired L*.
         * @return A hexadecimal representing the sRGB color. The color
         * has sufficiently close hue, chroma, and L* to the desired
         * values, if possible; otherwise, the hue and L* will be
         * sufficiently close, and chroma will be maximized.
         */
        static solveToInt(hueDegrees, chroma, lstar) {
            if (chroma < 0.0001 || lstar < 0.0001 || lstar > 99.9999) {
                return argbFromLstar(lstar);
            }
            hueDegrees = sanitizeDegreesDouble(hueDegrees);
            const hueRadians = hueDegrees / 180 * Math.PI;
            const y = yFromLstar(lstar);
            const exactAnswer = HctSolver.findResultByJ(hueRadians, chroma, y);
            if (exactAnswer !== 0) {
                return exactAnswer;
            }
            const linrgb = HctSolver.bisectToLimit(y, hueRadians);
            return argbFromLinrgb(linrgb);
        }
        /**
         * Finds an sRGB color with the given hue, chroma, and L*, if
         * possible.
         *
         * @param hueDegrees The desired hue, in degrees.
         * @param chroma The desired chroma.
         * @param lstar The desired L*.
         * @return An CAM16 object representing the sRGB color. The color
         * has sufficiently close hue, chroma, and L* to the desired
         * values, if possible; otherwise, the hue and L* will be
         * sufficiently close, and chroma will be maximized.
         */
        static solveToCam(hueDegrees, chroma, lstar) {
            return Cam16.fromInt(HctSolver.solveToInt(hueDegrees, chroma, lstar));
        }
    }
    HctSolver.SCALED_DISCOUNT_FROM_LINRGB = [
        [
            0.001200833568784504,
            0.002389694492170889,
            0.0002795742885861124,
        ],
        [
            0.0005891086651375999,
            0.0029785502573438758,
            0.0003270666104008398,
        ],
        [
            0.00010146692491640572,
            0.0005364214359186694,
            0.0032979401770712076,
        ],
    ];
    HctSolver.LINRGB_FROM_SCALED_DISCOUNT = [
        [
            1373.2198709594231,
            -1100.4251190754821,
            -7.278681089101213,
        ],
        [
            -271.815969077903,
            559.6580465940733,
            -32.46047482791194,
        ],
        [
            1.9622899599665666,
            -57.173814538844006,
            308.7233197812385,
        ],
    ];
    HctSolver.Y_FROM_LINRGB = [0.2126, 0.7152, 0.0722];
    HctSolver.CRITICAL_PLANES = [
        0.015176349177441876, 0.045529047532325624, 0.07588174588720938,
        0.10623444424209313, 0.13658714259697685, 0.16693984095186062,
        0.19729253930674434, 0.2276452376616281, 0.2579979360165119,
        0.28835063437139563, 0.3188300904430532, 0.350925934958123,
        0.3848314933096426, 0.42057480301049466, 0.458183274052838,
        0.4976837250274023, 0.5391024159806381, 0.5824650784040898,
        0.6277969426914107, 0.6751227633498623, 0.7244668422128921,
        0.775853049866786, 0.829304845476233, 0.8848452951698498,
        0.942497089126609, 1.0022825574869039, 1.0642236851973577,
        1.1283421258858297, 1.1946592148522128, 1.2631959812511864,
        1.3339731595349034, 1.407011200216447, 1.4823302800086415,
        1.5599503113873272, 1.6398909516233677, 1.7221716113234105,
        1.8068114625156377, 1.8938294463134073, 1.9832442801866852,
        2.075074464868551, 2.1693382909216234, 2.2660538449872063,
        2.36523901573795, 2.4669114995532007, 2.5710888059345764,
        2.6777882626779785, 2.7870270208169257, 2.898822059350997,
        3.0131901897720907, 3.1301480604002863, 3.2497121605402226,
        3.3718988244681087, 3.4967242352587946, 3.624204428461639,
        3.754355295633311, 3.887192587735158, 4.022731918402185,
        4.160988767090289, 4.301978482107941, 4.445716283538092,
        4.592217266055746, 4.741496401646282, 4.893568542229298,
        5.048448422192488, 5.20615066083972, 5.3666897647573375,
        5.5300801301023865, 5.696336044816294, 5.865471690767354,
        6.037501145825082, 6.212438385869475, 6.390297286737924,
        6.571091626112461, 6.7548350853498045, 6.941541251256611,
        7.131223617812143, 7.323895587840543, 7.5195704746346665,
        7.7182615035334345, 7.919981813454504, 8.124744458384042,
        8.332562408825165, 8.543448553206703, 8.757415699253682,
        8.974476575321063, 9.194643831691977, 9.417930041841839,
        9.644347703669503, 9.873909240696694, 10.106627003236781,
        10.342513269534024, 10.58158024687427, 10.8238400726681,
        11.069304815507364, 11.317986476196008, 11.569896988756009,
        11.825048221409341, 12.083451977536606, 12.345119996613247,
        12.610063955123938, 12.878295467455942, 13.149826086772048,
        13.42466730586372, 13.702830557985108, 13.984327217668513,
        14.269168601521828, 14.55736596900856, 14.848930523210871,
        15.143873411576273, 15.44220572664832, 15.743938506781891,
        16.04908273684337, 16.35764934889634, 16.66964922287304,
        16.985093187232053, 17.30399201960269, 17.62635644741625,
        17.95219714852476, 18.281524751807332, 18.614349837764564,
        18.95068293910138, 19.290534541298456, 19.633915083172692,
        19.98083495742689, 20.331304511189067, 20.685334046541502,
        21.042933821039977, 21.404114048223256, 21.76888489811322,
        22.137256497705877, 22.50923893145328, 22.884842241736916,
        23.264076429332462, 23.6469514538663, 24.033477234264016,
        24.42366364919083, 24.817520537484558, 25.21505769858089,
        25.61628489293138, 26.021211842414342, 26.429848230738664,
        26.842203703840827, 27.258287870275353, 27.678110301598522,
        28.10168053274597, 28.529008062403893, 28.96010235337422,
        29.39497283293396, 29.83362889318845, 30.276079891419332,
        30.722335150426627, 31.172403958865512, 31.62629557157785,
        32.08401920991837, 32.54558406207592, 33.010999283389665,
        33.4802739966603, 33.953417292456834, 34.430438229418264,
        34.911345834551085, 35.39614910352207, 35.88485700094671,
        36.37747846067349, 36.87402238606382, 37.37449765026789,
        37.87891309649659, 38.38727753828926, 38.89959975977785,
        39.41588851594697, 39.93615253289054, 40.460400508064545,
        40.98864111053629, 41.520882981230194, 42.05713473317016,
        42.597404951718396, 43.141702194811224, 43.6900349931913,
        44.24241185063697, 44.798841244188324, 45.35933162437017,
        45.92389141541209, 46.49252901546552, 47.065252796817916,
        47.64207110610409, 48.22299226451468, 48.808024568002054,
        49.3971762874833, 49.9904556690408, 50.587870934119984,
        51.189430279724725, 51.79514187861014, 52.40501387947288,
        53.0190544071392, 53.637271562750364, 54.259673423945976,
        54.88626804504493, 55.517063457223934, 56.15206766869424,
        56.79128866487574, 57.43473440856916, 58.08241284012621,
        58.734331877617365, 59.39049941699807, 60.05092333227251,
        60.715611475655585, 61.38457167773311, 62.057811747619894,
        62.7353394731159, 63.417162620860914, 64.10328893648692,
        64.79372614476921, 65.48848194977529, 66.18756403501224,
        66.89098006357258, 67.59873767827808, 68.31084450182222,
        69.02730813691093, 69.74813616640164, 70.47333615344107,
        71.20291564160104, 71.93688215501312, 72.67524319850172,
        73.41800625771542, 74.16517879925733, 74.9167682708136,
        75.67278210128072, 76.43322770089146, 77.1981124613393,
        77.96744375590167, 78.74122893956174, 79.51947534912904,
        80.30219030335869, 81.08938110306934, 81.88105503125999,
        82.67721935322541, 83.4778813166706, 84.28304815182372,
        85.09272707154808, 85.90692527145302, 86.72564993000343,
        87.54890820862819, 88.3767072518277, 89.2090541872801,
        90.04595612594655, 90.88742016217518, 91.73345337380438,
        92.58406282226491, 93.43925555268066, 94.29903859396902,
        95.16341895893969, 96.03240364439274, 96.9059996312159,
        97.78421388448044, 98.6670533535366, 99.55452497210776,
    ];

    /**
     * @license
     * Copyright 2021 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * A color system built using CAM16 hue and chroma, and L* from
     * L*a*b*.
     *
     * Using L* creates a link between the color system, contrast, and thus
     * accessibility. Contrast ratio depends on relative luminance, or Y in the XYZ
     * color space. L*, or perceptual luminance can be calculated from Y.
     *
     * Unlike Y, L* is linear to human perception, allowing trivial creation of
     * accurate color tones.
     *
     * Unlike contrast ratio, measuring contrast in L* is linear, and simple to
     * calculate. A difference of 40 in HCT tone guarantees a contrast ratio >= 3.0,
     * and a difference of 50 guarantees a contrast ratio >= 4.5.
     */
    /**
     * HCT, hue, chroma, and tone. A color system that provides a perceptually
     * accurate color measurement system that can also accurately render what colors
     * will appear as in different lighting environments.
     */
    class Hct {
        static from(hue, chroma, tone) {
            return new Hct(HctSolver.solveToInt(hue, chroma, tone));
        }
        /**
         * @param argb ARGB representation of a color.
         * @return HCT representation of a color in default viewing conditions
         */
        static fromInt(argb) {
            return new Hct(argb);
        }
        toInt() {
            return this.argb;
        }
        /**
         * A number, in degrees, representing ex. red, orange, yellow, etc.
         * Ranges from 0 <= hue < 360.
         */
        get hue() {
            return this.internalHue;
        }
        /**
         * @param newHue 0 <= newHue < 360; invalid values are corrected.
         * Chroma may decrease because chroma has a different maximum for any given
         * hue and tone.
         */
        set hue(newHue) {
            this.setInternalState(HctSolver.solveToInt(newHue, this.internalChroma, this.internalTone));
        }
        get chroma() {
            return this.internalChroma;
        }
        /**
         * @param newChroma 0 <= newChroma < ?
         * Chroma may decrease because chroma has a different maximum for any given
         * hue and tone.
         */
        set chroma(newChroma) {
            this.setInternalState(HctSolver.solveToInt(this.internalHue, newChroma, this.internalTone));
        }
        /** Lightness. Ranges from 0 to 100. */
        get tone() {
            return this.internalTone;
        }
        /**
         * @param newTone 0 <= newTone <= 100; invalid valids are corrected.
         * Chroma may decrease because chroma has a different maximum for any given
         * hue and tone.
         */
        set tone(newTone) {
            this.setInternalState(HctSolver.solveToInt(this.internalHue, this.internalChroma, newTone));
        }
        constructor(argb) {
            this.argb = argb;
            const cam = Cam16.fromInt(argb);
            this.internalHue = cam.hue;
            this.internalChroma = cam.chroma;
            this.internalTone = lstarFromArgb(argb);
            this.argb = argb;
        }
        setInternalState(argb) {
            const cam = Cam16.fromInt(argb);
            this.internalHue = cam.hue;
            this.internalChroma = cam.chroma;
            this.internalTone = lstarFromArgb(argb);
            this.argb = argb;
        }
        /**
         * Translates a color into different [ViewingConditions].
         *
         * Colors change appearance. They look different with lights on versus off,
         * the same color, as in hex code, on white looks different when on black.
         * This is called color relativity, most famously explicated by Josef Albers
         * in Interaction of Color.
         *
         * In color science, color appearance models can account for this and
         * calculate the appearance of a color in different settings. HCT is based on
         * CAM16, a color appearance model, and uses it to make these calculations.
         *
         * See [ViewingConditions.make] for parameters affecting color appearance.
         */
        inViewingConditions(vc) {
            // 1. Use CAM16 to find XYZ coordinates of color in specified VC.
            const cam = Cam16.fromInt(this.toInt());
            const viewedInVc = cam.xyzInViewingConditions(vc);
            // 2. Create CAM16 of those XYZ coordinates in default VC.
            const recastInVc = Cam16.fromXyzInViewingConditions(viewedInVc[0], viewedInVc[1], viewedInVc[2], ViewingConditions.make());
            // 3. Create HCT from:
            // - CAM16 using default VC with XYZ coordinates in specified VC.
            // - L* converted from Y in XYZ coordinates in specified VC.
            const recastHct = Hct.from(recastInVc.hue, recastInVc.chroma, lstarFromY(viewedInVc[1]));
            return recastHct;
        }
    }

    /**
     * @license
     * Copyright 2021 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // This file is automatically generated. Do not modify it.
    // material_color_utilities is designed to have a consistent API across
    // platforms and modular components that can be moved around easily. Using a
    // class as a namespace facilitates this.
    //
    // tslint:disable:class-as-namespace
    /**
     * Functions for blending in HCT and CAM16.
     */
    class Blend {
        /**
         * Blend the design color's HCT hue towards the key color's HCT
         * hue, in a way that leaves the original color recognizable and
         * recognizably shifted towards the key color.
         *
         * @param designColor ARGB representation of an arbitrary color.
         * @param sourceColor ARGB representation of the main theme color.
         * @return The design color with a hue shifted towards the
         * system's color, a slightly warmer/cooler variant of the design
         * color's hue.
         */
        static harmonize(designColor, sourceColor) {
            const fromHct = Hct.fromInt(designColor);
            const toHct = Hct.fromInt(sourceColor);
            const differenceDegrees$1 = differenceDegrees(fromHct.hue, toHct.hue);
            const rotationDegrees = Math.min(differenceDegrees$1 * 0.5, 15.0);
            const outputHue = sanitizeDegreesDouble(fromHct.hue +
                rotationDegrees * rotationDirection(fromHct.hue, toHct.hue));
            return Hct.from(outputHue, fromHct.chroma, fromHct.tone).toInt();
        }
        /**
         * Blends hue from one color into another. The chroma and tone of
         * the original color are maintained.
         *
         * @param from ARGB representation of color
         * @param to ARGB representation of color
         * @param amount how much blending to perform; 0.0 >= and <= 1.0
         * @return from, with a hue blended towards to. Chroma and tone
         * are constant.
         */
        static hctHue(from, to, amount) {
            const ucs = Blend.cam16Ucs(from, to, amount);
            const ucsCam = Cam16.fromInt(ucs);
            const fromCam = Cam16.fromInt(from);
            const blended = Hct.from(ucsCam.hue, fromCam.chroma, lstarFromArgb(from));
            return blended.toInt();
        }
        /**
         * Blend in CAM16-UCS space.
         *
         * @param from ARGB representation of color
         * @param to ARGB representation of color
         * @param amount how much blending to perform; 0.0 >= and <= 1.0
         * @return from, blended towards to. Hue, chroma, and tone will
         * change.
         */
        static cam16Ucs(from, to, amount) {
            const fromCam = Cam16.fromInt(from);
            const toCam = Cam16.fromInt(to);
            const fromJ = fromCam.jstar;
            const fromA = fromCam.astar;
            const fromB = fromCam.bstar;
            const toJ = toCam.jstar;
            const toA = toCam.astar;
            const toB = toCam.bstar;
            const jstar = fromJ + (toJ - fromJ) * amount;
            const astar = fromA + (toA - fromA) * amount;
            const bstar = fromB + (toB - fromB) * amount;
            return Cam16.fromUcs(jstar, astar, bstar).toInt();
        }
    }

    /**
     * @license
     * Copyright 2022 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // material_color_utilities is designed to have a consistent API across
    // platforms and modular components that can be moved around easily. Using a
    // class as a namespace facilitates this.
    //
    // tslint:disable:class-as-namespace
    /**
     * Utility methods for calculating contrast given two colors, or calculating a
     * color given one color and a contrast ratio.
     *
     * Contrast ratio is calculated using XYZ's Y. When linearized to match human
     * perception, Y becomes HCT's tone and L*a*b*'s' L*. Informally, this is the
     * lightness of a color.
     *
     * Methods refer to tone, T in the the HCT color space.
     * Tone is equivalent to L* in the L*a*b* color space, or L in the LCH color
     * space.
     */
    class Contrast {
        /**
         * Returns a contrast ratio, which ranges from 1 to 21.
         *
         * @param toneA Tone between 0 and 100. Values outside will be clamped.
         * @param toneB Tone between 0 and 100. Values outside will be clamped.
         */
        static ratioOfTones(toneA, toneB) {
            toneA = clampDouble(0.0, 100.0, toneA);
            toneB = clampDouble(0.0, 100.0, toneB);
            return Contrast.ratioOfYs(yFromLstar(toneA), yFromLstar(toneB));
        }
        static ratioOfYs(y1, y2) {
            const lighter = y1 > y2 ? y1 : y2;
            const darker = (lighter === y2) ? y1 : y2;
            return (lighter + 5.0) / (darker + 5.0);
        }
        /**
         * Returns a tone >= tone parameter that ensures ratio parameter.
         * Return value is between 0 and 100.
         * Returns -1 if ratio cannot be achieved with tone parameter.
         *
         * @param tone Tone return value must contrast with.
         * Range is 0 to 100. Invalid values will result in -1 being returned.
         * @param ratio Contrast ratio of return value and tone.
         * Range is 1 to 21, invalid values have undefined behavior.
         */
        static lighter(tone, ratio) {
            if (tone < 0.0 || tone > 100.0) {
                return -1.0;
            }
            const darkY = yFromLstar(tone);
            const lightY = ratio * (darkY + 5.0) - 5.0;
            const realContrast = Contrast.ratioOfYs(lightY, darkY);
            const delta = Math.abs(realContrast - ratio);
            if (realContrast < ratio && delta > 0.04) {
                return -1;
            }
            // Ensure gamut mapping, which requires a 'range' on tone, will still result
            // the correct ratio by darkening slightly.
            const returnValue = lstarFromY(lightY) + 0.4;
            if (returnValue < 0 || returnValue > 100) {
                return -1;
            }
            return returnValue;
        }
        /**
         * Returns a tone <= tone parameter that ensures ratio parameter.
         * Return value is between 0 and 100.
         * Returns -1 if ratio cannot be achieved with tone parameter.
         *
         * @param tone Tone return value must contrast with.
         * Range is 0 to 100. Invalid values will result in -1 being returned.
         * @param ratio Contrast ratio of return value and tone.
         * Range is 1 to 21, invalid values have undefined behavior.
         */
        static darker(tone, ratio) {
            if (tone < 0.0 || tone > 100.0) {
                return -1.0;
            }
            const lightY = yFromLstar(tone);
            const darkY = ((lightY + 5.0) / ratio) - 5.0;
            const realContrast = Contrast.ratioOfYs(lightY, darkY);
            const delta = Math.abs(realContrast - ratio);
            if (realContrast < ratio && delta > 0.04) {
                return -1;
            }
            // Ensure gamut mapping, which requires a 'range' on tone, will still result
            // the correct ratio by darkening slightly.
            const returnValue = lstarFromY(darkY) - 0.4;
            if (returnValue < 0 || returnValue > 100) {
                return -1;
            }
            return returnValue;
        }
        /**
         * Returns a tone >= tone parameter that ensures ratio parameter.
         * Return value is between 0 and 100.
         * Returns 100 if ratio cannot be achieved with tone parameter.
         *
         * This method is unsafe because the returned value is guaranteed to be in
         * bounds for tone, i.e. between 0 and 100. However, that value may not reach
         * the ratio with tone. For example, there is no color lighter than T100.
         *
         * @param tone Tone return value must contrast with.
         * Range is 0 to 100. Invalid values will result in 100 being returned.
         * @param ratio Desired contrast ratio of return value and tone parameter.
         * Range is 1 to 21, invalid values have undefined behavior.
         */
        static lighterUnsafe(tone, ratio) {
            const lighterSafe = Contrast.lighter(tone, ratio);
            return (lighterSafe < 0.0) ? 100.0 : lighterSafe;
        }
        /**
         * Returns a tone >= tone parameter that ensures ratio parameter.
         * Return value is between 0 and 100.
         * Returns 100 if ratio cannot be achieved with tone parameter.
         *
         * This method is unsafe because the returned value is guaranteed to be in
         * bounds for tone, i.e. between 0 and 100. However, that value may not reach
         * the [ratio with [tone]. For example, there is no color darker than T0.
         *
         * @param tone Tone return value must contrast with.
         * Range is 0 to 100. Invalid values will result in 0 being returned.
         * @param ratio Desired contrast ratio of return value and tone parameter.
         * Range is 1 to 21, invalid values have undefined behavior.
         */
        static darkerUnsafe(tone, ratio) {
            const darkerSafe = Contrast.darker(tone, ratio);
            return (darkerSafe < 0.0) ? 0.0 : darkerSafe;
        }
    }

    /**
     * @license
     * Copyright 2023 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // material_color_utilities is designed to have a consistent API across
    // platforms and modular components that can be moved around easily. Using a
    // class as a namespace facilitates this.
    //
    // tslint:disable:class-as-namespace
    /**
     * Check and/or fix universally disliked colors.
     * Color science studies of color preference indicate universal distaste for
     * dark yellow-greens, and also show this is correlated to distate for
     * biological waste and rotting food.
     *
     * See Palmer and Schloss, 2010 or Schloss and Palmer's Chapter 21 in Handbook
     * of Color Psychology (2015).
     */
    class DislikeAnalyzer {
        /**
         * Returns true if a color is disliked.
         *
         * @param hct A color to be judged.
         * @return Whether the color is disliked.
         *
         * Disliked is defined as a dark yellow-green that is not neutral.
         */
        static isDisliked(hct) {
            const huePasses = Math.round(hct.hue) >= 90.0 && Math.round(hct.hue) <= 111.0;
            const chromaPasses = Math.round(hct.chroma) > 16.0;
            const tonePasses = Math.round(hct.tone) < 65.0;
            return huePasses && chromaPasses && tonePasses;
        }
        /**
         * If a color is disliked, lighten it to make it likable.
         *
         * @param hct A color to be judged.
         * @return A new color if the original color is disliked, or the original
         *   color if it is acceptable.
         */
        static fixIfDisliked(hct) {
            if (DislikeAnalyzer.isDisliked(hct)) {
                return Hct.from(hct.hue, hct.chroma, 70.0);
            }
            return hct;
        }
    }

    /**
     * @license
     * Copyright 2022 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * A color that adjusts itself based on UI state provided by DynamicScheme.
     *
     * Colors without backgrounds do not change tone when contrast changes. Colors
     * with backgrounds become closer to their background as contrast lowers, and
     * further when contrast increases.
     *
     * Prefer static constructors. They require either a hexcode, a palette and
     * tone, or a hue and chroma. Optionally, they can provide a background
     * DynamicColor.
     */
    class DynamicColor {
        /**
         * Create a DynamicColor defined by a TonalPalette and HCT tone.
         *
         * @param args Functions with DynamicScheme as input. Must provide a palette
         * and tone. May provide a background DynamicColor and ToneDeltaConstraint.
         */
        static fromPalette(args) {
            return new DynamicColor(args.name ?? '', args.palette, args.tone, args.isBackground ?? false, args.background, args.secondBackground, args.contrastCurve, args.toneDeltaPair);
        }
        /**
         * The base constructor for DynamicColor.
         *
         * _Strongly_ prefer using one of the convenience constructors. This class is
         * arguably too flexible to ensure it can support any scenario. Functional
         * arguments allow  overriding without risks that come with subclasses.
         *
         * For example, the default behavior of adjust tone at max contrast
         * to be at a 7.0 ratio with its background is principled and
         * matches accessibility guidance. That does not mean it's the desired
         * approach for _every_ design system, and every color pairing,
         * always, in every case.
         *
         * @param name The name of the dynamic color. Defaults to empty.
         * @param palette Function that provides a TonalPalette given
         * DynamicScheme. A TonalPalette is defined by a hue and chroma, so this
         * replaces the need to specify hue/chroma. By providing a tonal palette, when
         * contrast adjustments are made, intended chroma can be preserved.
         * @param tone Function that provides a tone, given a DynamicScheme.
         * @param isBackground Whether this dynamic color is a background, with
         * some other color as the foreground. Defaults to false.
         * @param background The background of the dynamic color (as a function of a
         *     `DynamicScheme`), if it exists.
         * @param secondBackground A second background of the dynamic color (as a
         *     function of a `DynamicScheme`), if it
         * exists.
         * @param contrastCurve A `ContrastCurve` object specifying how its contrast
         * against its background should behave in various contrast levels options.
         * @param toneDeltaPair A `ToneDeltaPair` object specifying a tone delta
         * constraint between two colors. One of them must be the color being
         * constructed.
         */
        constructor(name, palette, tone, isBackground, background, secondBackground, contrastCurve, toneDeltaPair) {
            this.name = name;
            this.palette = palette;
            this.tone = tone;
            this.isBackground = isBackground;
            this.background = background;
            this.secondBackground = secondBackground;
            this.contrastCurve = contrastCurve;
            this.toneDeltaPair = toneDeltaPair;
            this.hctCache = new Map();
            if ((!background) && secondBackground) {
                throw new Error(`Color ${name} has secondBackground` +
                    `defined, but background is not defined.`);
            }
            if ((!background) && contrastCurve) {
                throw new Error(`Color ${name} has contrastCurve` +
                    `defined, but background is not defined.`);
            }
            if (background && !contrastCurve) {
                throw new Error(`Color ${name} has background` +
                    `defined, but contrastCurve is not defined.`);
            }
        }
        /**
         * Return a ARGB integer (i.e. a hex code).
         *
         * @param scheme Defines the conditions of the user interface, for example,
         * whether or not it is dark mode or light mode, and what the desired
         * contrast level is.
         */
        getArgb(scheme) {
            return this.getHct(scheme).toInt();
        }
        /**
         * Return a color, expressed in the HCT color space, that this
         * DynamicColor is under the conditions in scheme.
         *
         * @param scheme Defines the conditions of the user interface, for example,
         * whether or not it is dark mode or light mode, and what the desired
         * contrast level is.
         */
        getHct(scheme) {
            const cachedAnswer = this.hctCache.get(scheme);
            if (cachedAnswer != null) {
                return cachedAnswer;
            }
            const tone = this.getTone(scheme);
            const answer = this.palette(scheme).getHct(tone);
            if (this.hctCache.size > 4) {
                this.hctCache.clear();
            }
            this.hctCache.set(scheme, answer);
            return answer;
        }
        /**
         * Return a tone, T in the HCT color space, that this DynamicColor is under
         * the conditions in scheme.
         *
         * @param scheme Defines the conditions of the user interface, for example,
         * whether or not it is dark mode or light mode, and what the desired
         * contrast level is.
         */
        getTone(scheme) {
            const decreasingContrast = scheme.contrastLevel < 0;
            // Case 1: dual foreground, pair of colors with delta constraint.
            if (this.toneDeltaPair) {
                const toneDeltaPair = this.toneDeltaPair(scheme);
                const roleA = toneDeltaPair.roleA;
                const roleB = toneDeltaPair.roleB;
                const delta = toneDeltaPair.delta;
                const polarity = toneDeltaPair.polarity;
                const stayTogether = toneDeltaPair.stayTogether;
                const bg = this.background(scheme);
                const bgTone = bg.getTone(scheme);
                const aIsNearer = (polarity === 'nearer' ||
                    (polarity === 'lighter' && !scheme.isDark) ||
                    (polarity === 'darker' && scheme.isDark));
                const nearer = aIsNearer ? roleA : roleB;
                const farther = aIsNearer ? roleB : roleA;
                const amNearer = this.name === nearer.name;
                const expansionDir = scheme.isDark ? 1 : -1;
                // 1st round: solve to min, each
                const nContrast = nearer.contrastCurve.getContrast(scheme.contrastLevel);
                const fContrast = farther.contrastCurve.getContrast(scheme.contrastLevel);
                // If a color is good enough, it is not adjusted.
                // Initial and adjusted tones for `nearer`
                const nInitialTone = nearer.tone(scheme);
                let nTone = Contrast.ratioOfTones(bgTone, nInitialTone) >= nContrast ?
                    nInitialTone :
                    DynamicColor.foregroundTone(bgTone, nContrast);
                // Initial and adjusted tones for `farther`
                const fInitialTone = farther.tone(scheme);
                let fTone = Contrast.ratioOfTones(bgTone, fInitialTone) >= fContrast ?
                    fInitialTone :
                    DynamicColor.foregroundTone(bgTone, fContrast);
                if (decreasingContrast) {
                    // If decreasing contrast, adjust color to the "bare minimum"
                    // that satisfies contrast.
                    nTone = DynamicColor.foregroundTone(bgTone, nContrast);
                    fTone = DynamicColor.foregroundTone(bgTone, fContrast);
                }
                if ((fTone - nTone) * expansionDir >= delta) ;
                else {
                    // 2nd round: expand farther to match delta.
                    fTone = clampDouble(0, 100, nTone + delta * expansionDir);
                    if ((fTone - nTone) * expansionDir >= delta) ;
                    else {
                        // 3rd round: contract nearer to match delta.
                        nTone = clampDouble(0, 100, fTone - delta * expansionDir);
                    }
                }
                // Avoids the 50-59 awkward zone.
                if (50 <= nTone && nTone < 60) {
                    // If `nearer` is in the awkward zone, move it away, together with
                    // `farther`.
                    if (expansionDir > 0) {
                        nTone = 60;
                        fTone = Math.max(fTone, nTone + delta * expansionDir);
                    }
                    else {
                        nTone = 49;
                        fTone = Math.min(fTone, nTone + delta * expansionDir);
                    }
                }
                else if (50 <= fTone && fTone < 60) {
                    if (stayTogether) {
                        // Fixes both, to avoid two colors on opposite sides of the "awkward
                        // zone".
                        if (expansionDir > 0) {
                            nTone = 60;
                            fTone = Math.max(fTone, nTone + delta * expansionDir);
                        }
                        else {
                            nTone = 49;
                            fTone = Math.min(fTone, nTone + delta * expansionDir);
                        }
                    }
                    else {
                        // Not required to stay together; fixes just one.
                        if (expansionDir > 0) {
                            fTone = 60;
                        }
                        else {
                            fTone = 49;
                        }
                    }
                }
                // Returns `nTone` if this color is `nearer`, otherwise `fTone`.
                return amNearer ? nTone : fTone;
            }
            else {
                // Case 2: No contrast pair; just solve for itself.
                let answer = this.tone(scheme);
                if (this.background == null) {
                    return answer; // No adjustment for colors with no background.
                }
                const bgTone = this.background(scheme).getTone(scheme);
                const desiredRatio = this.contrastCurve.getContrast(scheme.contrastLevel);
                if (Contrast.ratioOfTones(bgTone, answer) >= desiredRatio) ;
                else {
                    // Rough improvement.
                    answer = DynamicColor.foregroundTone(bgTone, desiredRatio);
                }
                if (decreasingContrast) {
                    answer = DynamicColor.foregroundTone(bgTone, desiredRatio);
                }
                if (this.isBackground && 50 <= answer && answer < 60) {
                    // Must adjust
                    if (Contrast.ratioOfTones(49, bgTone) >= desiredRatio) {
                        answer = 49;
                    }
                    else {
                        answer = 60;
                    }
                }
                if (this.secondBackground) {
                    // Case 3: Adjust for dual backgrounds.
                    const [bg1, bg2] = [this.background, this.secondBackground];
                    const [bgTone1, bgTone2] = [bg1(scheme).getTone(scheme), bg2(scheme).getTone(scheme)];
                    const [upper, lower] = [Math.max(bgTone1, bgTone2), Math.min(bgTone1, bgTone2)];
                    if (Contrast.ratioOfTones(upper, answer) >= desiredRatio &&
                        Contrast.ratioOfTones(lower, answer) >= desiredRatio) {
                        return answer;
                    }
                    // The darkest light tone that satisfies the desired ratio,
                    // or -1 if such ratio cannot be reached.
                    const lightOption = Contrast.lighter(upper, desiredRatio);
                    // The lightest dark tone that satisfies the desired ratio,
                    // or -1 if such ratio cannot be reached.
                    const darkOption = Contrast.darker(lower, desiredRatio);
                    // Tones suitable for the foreground.
                    const availables = [];
                    if (lightOption !== -1)
                        availables.push(lightOption);
                    if (darkOption !== -1)
                        availables.push(darkOption);
                    const prefersLight = DynamicColor.tonePrefersLightForeground(bgTone1) ||
                        DynamicColor.tonePrefersLightForeground(bgTone2);
                    if (prefersLight) {
                        return (lightOption < 0) ? 100 : lightOption;
                    }
                    if (availables.length === 1) {
                        return availables[0];
                    }
                    return (darkOption < 0) ? 0 : darkOption;
                }
                return answer;
            }
        }
        /**
         * Given a background tone, find a foreground tone, while ensuring they reach
         * a contrast ratio that is as close to [ratio] as possible.
         *
         * @param bgTone Tone in HCT. Range is 0 to 100, undefined behavior when it
         *     falls outside that range.
         * @param ratio The contrast ratio desired between bgTone and the return
         *     value.
         */
        static foregroundTone(bgTone, ratio) {
            const lighterTone = Contrast.lighterUnsafe(bgTone, ratio);
            const darkerTone = Contrast.darkerUnsafe(bgTone, ratio);
            const lighterRatio = Contrast.ratioOfTones(lighterTone, bgTone);
            const darkerRatio = Contrast.ratioOfTones(darkerTone, bgTone);
            const preferLighter = DynamicColor.tonePrefersLightForeground(bgTone);
            if (preferLighter) {
                // This handles an edge case where the initial contrast ratio is high
                // (ex. 13.0), and the ratio passed to the function is that high
                // ratio, and both the lighter and darker ratio fails to pass that
                // ratio.
                //
                // This was observed with Tonal Spot's On Primary Container turning
                // black momentarily between high and max contrast in light mode. PC's
                // standard tone was T90, OPC's was T10, it was light mode, and the
                // contrast value was 0.6568521221032331.
                const negligibleDifference = Math.abs(lighterRatio - darkerRatio) < 0.1 &&
                    lighterRatio < ratio && darkerRatio < ratio;
                return lighterRatio >= ratio || lighterRatio >= darkerRatio ||
                    negligibleDifference ?
                    lighterTone :
                    darkerTone;
            }
            else {
                return darkerRatio >= ratio || darkerRatio >= lighterRatio ? darkerTone :
                    lighterTone;
            }
        }
        /**
         * Returns whether [tone] prefers a light foreground.
         *
         * People prefer white foregrounds on ~T60-70. Observed over time, and also
         * by Andrew Somers during research for APCA.
         *
         * T60 used as to create the smallest discontinuity possible when skipping
         * down to T49 in order to ensure light foregrounds.
         * Since `tertiaryContainer` in dark monochrome scheme requires a tone of
         * 60, it should not be adjusted. Therefore, 60 is excluded here.
         */
        static tonePrefersLightForeground(tone) {
            return Math.round(tone) < 60.0;
        }
        /**
         * Returns whether [tone] can reach a contrast ratio of 4.5 with a lighter
         * color.
         */
        static toneAllowsLightForeground(tone) {
            return Math.round(tone) <= 49.0;
        }
        /**
         * Adjust a tone such that white has 4.5 contrast, if the tone is
         * reasonably close to supporting it.
         */
        static enableLightForeground(tone) {
            if (DynamicColor.tonePrefersLightForeground(tone) &&
                !DynamicColor.toneAllowsLightForeground(tone)) {
                return 49.0;
            }
            return tone;
        }
    }

    /**
     * @license
     * Copyright 2022 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Set of themes supported by Dynamic Color.
     * Instantiate the corresponding subclass, ex. SchemeTonalSpot, to create
     * colors corresponding to the theme.
     */
    var Variant;
    (function (Variant) {
        Variant[Variant["MONOCHROME"] = 0] = "MONOCHROME";
        Variant[Variant["NEUTRAL"] = 1] = "NEUTRAL";
        Variant[Variant["TONAL_SPOT"] = 2] = "TONAL_SPOT";
        Variant[Variant["VIBRANT"] = 3] = "VIBRANT";
        Variant[Variant["EXPRESSIVE"] = 4] = "EXPRESSIVE";
        Variant[Variant["FIDELITY"] = 5] = "FIDELITY";
        Variant[Variant["CONTENT"] = 6] = "CONTENT";
        Variant[Variant["RAINBOW"] = 7] = "RAINBOW";
        Variant[Variant["FRUIT_SALAD"] = 8] = "FRUIT_SALAD";
    })(Variant || (Variant = {}));

    /**
     * @license
     * Copyright 2023 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * A class containing the contrast curve for a dynamic color on its background.
     *
     * The four values correspond to contrast requirements for contrast levels
     * -1.0, 0.0, 0.5, and 1.0, respectively.
     */
    class ContrastCurve {
        /**
         * Creates a `ContrastCurve` object.
         *
         * @param low Contrast requirement for contrast level -1.0
         * @param normal Contrast requirement for contrast level 0.0
         * @param medium Contrast requirement for contrast level 0.5
         * @param high Contrast requirement for contrast level 1.0
         */
        constructor(low, normal, medium, high) {
            this.low = low;
            this.normal = normal;
            this.medium = medium;
            this.high = high;
        }
        /**
         * Returns the contrast ratio at a given contrast level.
         *
         * @param contrastLevel The contrast level. 0.0 is the default (normal);
         * -1.0 is the lowest; 1.0 is the highest.
         * @return The contrast ratio, a number between 1.0 and 21.0.
         */
        getContrast(contrastLevel) {
            if (contrastLevel <= -1.0) {
                return this.low;
            }
            else if (contrastLevel < 0.0) {
                return lerp(this.low, this.normal, (contrastLevel - (-1)) / 1);
            }
            else if (contrastLevel < 0.5) {
                return lerp(this.normal, this.medium, (contrastLevel - 0) / 0.5);
            }
            else if (contrastLevel < 1.0) {
                return lerp(this.medium, this.high, (contrastLevel - 0.5) / 0.5);
            }
            else {
                return this.high;
            }
        }
    }

    /**
     * @license
     * Copyright 2023 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Documents a constraint between two DynamicColors, in which their tones must
     * have a certain distance from each other.
     *
     * Prefer a DynamicColor with a background, this is for special cases when
     * designers want tonal distance, literally contrast, between two colors that
     * don't have a background / foreground relationship or a contrast guarantee.
     */
    class ToneDeltaPair {
        /**
         * Documents a constraint in tone distance between two DynamicColors.
         *
         * The polarity is an adjective that describes "A", compared to "B".
         *
         * For instance, ToneDeltaPair(A, B, 15, 'darker', stayTogether) states that
         * A's tone should be at least 15 darker than B's.
         *
         * 'nearer' and 'farther' describes closeness to the surface roles. For
         * instance, ToneDeltaPair(A, B, 10, 'nearer', stayTogether) states that A
         * should be 10 lighter than B in light mode, and 10 darker than B in dark
         * mode.
         *
         * @param roleA The first role in a pair.
         * @param roleB The second role in a pair.
         * @param delta Required difference between tones. Absolute value, negative
         * values have undefined behavior.
         * @param polarity The relative relation between tones of roleA and roleB,
         * as described above.
         * @param stayTogether Whether these two roles should stay on the same side of
         * the "awkward zone" (T50-59). This is necessary for certain cases where
         * one role has two backgrounds.
         */
        constructor(roleA, roleB, delta, polarity, stayTogether) {
            this.roleA = roleA;
            this.roleB = roleB;
            this.delta = delta;
            this.polarity = polarity;
            this.stayTogether = stayTogether;
        }
    }

    /**
     * @license
     * Copyright 2022 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    function isFidelity(scheme) {
        return scheme.variant === Variant.FIDELITY ||
            scheme.variant === Variant.CONTENT;
    }
    function isMonochrome(scheme) {
        return scheme.variant === Variant.MONOCHROME;
    }
    function findDesiredChromaByTone(hue, chroma, tone, byDecreasingTone) {
        let answer = tone;
        let closestToChroma = Hct.from(hue, chroma, tone);
        if (closestToChroma.chroma < chroma) {
            let chromaPeak = closestToChroma.chroma;
            while (closestToChroma.chroma < chroma) {
                answer += byDecreasingTone ? -1.0 : 1.0;
                const potentialSolution = Hct.from(hue, chroma, answer);
                if (chromaPeak > potentialSolution.chroma) {
                    break;
                }
                if (Math.abs(potentialSolution.chroma - chroma) < 0.4) {
                    break;
                }
                const potentialDelta = Math.abs(potentialSolution.chroma - chroma);
                const currentDelta = Math.abs(closestToChroma.chroma - chroma);
                if (potentialDelta < currentDelta) {
                    closestToChroma = potentialSolution;
                }
                chromaPeak = Math.max(chromaPeak, potentialSolution.chroma);
            }
        }
        return answer;
    }
    function viewingConditionsForAlbers(scheme) {
        return ViewingConditions.make(
        /*whitePoint=*/ undefined, 
        /*adaptingLuminance=*/ undefined, 
        /*backgroundLstar=*/ scheme.isDark ? 30 : 80, 
        /*surround=*/ undefined, 
        /*discountingIlluminant=*/ undefined);
    }
    function performAlbers(prealbers, scheme) {
        const albersd = prealbers.inViewingConditions(viewingConditionsForAlbers(scheme));
        if (DynamicColor.tonePrefersLightForeground(prealbers.tone) &&
            !DynamicColor.toneAllowsLightForeground(albersd.tone)) {
            return DynamicColor.enableLightForeground(prealbers.tone);
        }
        else {
            return DynamicColor.enableLightForeground(albersd.tone);
        }
    }
    /**
     * DynamicColors for the colors in the Material Design system.
     */
    // Material Color Utilities namespaces the various utilities it provides.
    // tslint:disable-next-line:class-as-namespace
    class MaterialDynamicColors {
        static highestSurface(s) {
            return s.isDark ? MaterialDynamicColors.surfaceBright :
                MaterialDynamicColors.surfaceDim;
        }
    }
    MaterialDynamicColors.contentAccentToneDelta = 15.0;
    MaterialDynamicColors.primaryPaletteKeyColor = DynamicColor.fromPalette({
        name: 'primary_palette_key_color',
        palette: (s) => s.primaryPalette,
        tone: (s) => s.primaryPalette.keyColor.tone,
    });
    MaterialDynamicColors.secondaryPaletteKeyColor = DynamicColor.fromPalette({
        name: 'secondary_palette_key_color',
        palette: (s) => s.secondaryPalette,
        tone: (s) => s.secondaryPalette.keyColor.tone,
    });
    MaterialDynamicColors.tertiaryPaletteKeyColor = DynamicColor.fromPalette({
        name: 'tertiary_palette_key_color',
        palette: (s) => s.tertiaryPalette,
        tone: (s) => s.tertiaryPalette.keyColor.tone,
    });
    MaterialDynamicColors.neutralPaletteKeyColor = DynamicColor.fromPalette({
        name: 'neutral_palette_key_color',
        palette: (s) => s.neutralPalette,
        tone: (s) => s.neutralPalette.keyColor.tone,
    });
    MaterialDynamicColors.neutralVariantPaletteKeyColor = DynamicColor.fromPalette({
        name: 'neutral_variant_palette_key_color',
        palette: (s) => s.neutralVariantPalette,
        tone: (s) => s.neutralVariantPalette.keyColor.tone,
    });
    MaterialDynamicColors.background = DynamicColor.fromPalette({
        name: 'background',
        palette: (s) => s.neutralPalette,
        tone: (s) => s.isDark ? 6 : 98,
        isBackground: true,
    });
    MaterialDynamicColors.onBackground = DynamicColor.fromPalette({
        name: 'on_background',
        palette: (s) => s.neutralPalette,
        tone: (s) => s.isDark ? 90 : 10,
        background: (s) => MaterialDynamicColors.background,
        contrastCurve: new ContrastCurve(3, 3, 4.5, 7),
    });
    MaterialDynamicColors.surface = DynamicColor.fromPalette({
        name: 'surface',
        palette: (s) => s.neutralPalette,
        tone: (s) => s.isDark ? 6 : 98,
        isBackground: true,
    });
    MaterialDynamicColors.surfaceDim = DynamicColor.fromPalette({
        name: 'surface_dim',
        palette: (s) => s.neutralPalette,
        tone: (s) => s.isDark ? 6 : 87,
        isBackground: true,
    });
    MaterialDynamicColors.surfaceBright = DynamicColor.fromPalette({
        name: 'surface_bright',
        palette: (s) => s.neutralPalette,
        tone: (s) => s.isDark ? 24 : 98,
        isBackground: true,
    });
    MaterialDynamicColors.surfaceContainerLowest = DynamicColor.fromPalette({
        name: 'surface_container_lowest',
        palette: (s) => s.neutralPalette,
        tone: (s) => s.isDark ? 4 : 100,
        isBackground: true,
    });
    MaterialDynamicColors.surfaceContainerLow = DynamicColor.fromPalette({
        name: 'surface_container_low',
        palette: (s) => s.neutralPalette,
        tone: (s) => s.isDark ? 10 : 96,
        isBackground: true,
    });
    MaterialDynamicColors.surfaceContainer = DynamicColor.fromPalette({
        name: 'surface_container',
        palette: (s) => s.neutralPalette,
        tone: (s) => s.isDark ? 12 : 94,
        isBackground: true,
    });
    MaterialDynamicColors.surfaceContainerHigh = DynamicColor.fromPalette({
        name: 'surface_container_high',
        palette: (s) => s.neutralPalette,
        tone: (s) => s.isDark ? 17 : 92,
        isBackground: true,
    });
    MaterialDynamicColors.surfaceContainerHighest = DynamicColor.fromPalette({
        name: 'surface_container_highest',
        palette: (s) => s.neutralPalette,
        tone: (s) => s.isDark ? 22 : 90,
        isBackground: true,
    });
    MaterialDynamicColors.onSurface = DynamicColor.fromPalette({
        name: 'on_surface',
        palette: (s) => s.neutralPalette,
        tone: (s) => s.isDark ? 90 : 10,
        background: (s) => MaterialDynamicColors.highestSurface(s),
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21),
    });
    MaterialDynamicColors.surfaceVariant = DynamicColor.fromPalette({
        name: 'surface_variant',
        palette: (s) => s.neutralVariantPalette,
        tone: (s) => s.isDark ? 30 : 90,
        isBackground: true,
    });
    MaterialDynamicColors.onSurfaceVariant = DynamicColor.fromPalette({
        name: 'on_surface_variant',
        palette: (s) => s.neutralVariantPalette,
        tone: (s) => s.isDark ? 80 : 30,
        background: (s) => MaterialDynamicColors.highestSurface(s),
        contrastCurve: new ContrastCurve(3, 4.5, 7, 11),
    });
    MaterialDynamicColors.inverseSurface = DynamicColor.fromPalette({
        name: 'inverse_surface',
        palette: (s) => s.neutralPalette,
        tone: (s) => s.isDark ? 90 : 20,
    });
    MaterialDynamicColors.inverseOnSurface = DynamicColor.fromPalette({
        name: 'inverse_on_surface',
        palette: (s) => s.neutralPalette,
        tone: (s) => s.isDark ? 20 : 95,
        background: (s) => MaterialDynamicColors.inverseSurface,
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21),
    });
    MaterialDynamicColors.outline = DynamicColor.fromPalette({
        name: 'outline',
        palette: (s) => s.neutralVariantPalette,
        tone: (s) => s.isDark ? 60 : 50,
        background: (s) => MaterialDynamicColors.highestSurface(s),
        contrastCurve: new ContrastCurve(1.5, 3, 4.5, 7),
    });
    MaterialDynamicColors.outlineVariant = DynamicColor.fromPalette({
        name: 'outline_variant',
        palette: (s) => s.neutralVariantPalette,
        tone: (s) => s.isDark ? 30 : 80,
        background: (s) => MaterialDynamicColors.highestSurface(s),
        contrastCurve: new ContrastCurve(1, 1, 3, 7),
    });
    MaterialDynamicColors.shadow = DynamicColor.fromPalette({
        name: 'shadow',
        palette: (s) => s.neutralPalette,
        tone: (s) => 0,
    });
    MaterialDynamicColors.scrim = DynamicColor.fromPalette({
        name: 'scrim',
        palette: (s) => s.neutralPalette,
        tone: (s) => 0,
    });
    MaterialDynamicColors.surfaceTint = DynamicColor.fromPalette({
        name: 'surface_tint',
        palette: (s) => s.primaryPalette,
        tone: (s) => s.isDark ? 80 : 40,
        isBackground: true,
    });
    MaterialDynamicColors.primary = DynamicColor.fromPalette({
        name: 'primary',
        palette: (s) => s.primaryPalette,
        tone: (s) => {
            if (isMonochrome(s)) {
                return s.isDark ? 100 : 0;
            }
            return s.isDark ? 80 : 40;
        },
        isBackground: true,
        background: (s) => MaterialDynamicColors.highestSurface(s),
        contrastCurve: new ContrastCurve(3, 4.5, 7, 11),
        toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.primaryContainer, MaterialDynamicColors.primary, 15, 'nearer', false),
    });
    MaterialDynamicColors.onPrimary = DynamicColor.fromPalette({
        name: 'on_primary',
        palette: (s) => s.primaryPalette,
        tone: (s) => {
            if (isMonochrome(s)) {
                return s.isDark ? 10 : 90;
            }
            return s.isDark ? 20 : 100;
        },
        background: (s) => MaterialDynamicColors.primary,
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21),
    });
    MaterialDynamicColors.primaryContainer = DynamicColor.fromPalette({
        name: 'primary_container',
        palette: (s) => s.primaryPalette,
        tone: (s) => {
            if (isFidelity(s)) {
                return performAlbers(s.sourceColorHct, s);
            }
            if (isMonochrome(s)) {
                return s.isDark ? 85 : 25;
            }
            return s.isDark ? 30 : 90;
        },
        isBackground: true,
        background: (s) => MaterialDynamicColors.highestSurface(s),
        contrastCurve: new ContrastCurve(1, 1, 3, 7),
        toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.primaryContainer, MaterialDynamicColors.primary, 15, 'nearer', false),
    });
    MaterialDynamicColors.onPrimaryContainer = DynamicColor.fromPalette({
        name: 'on_primary_container',
        palette: (s) => s.primaryPalette,
        tone: (s) => {
            if (isFidelity(s)) {
                return DynamicColor.foregroundTone(MaterialDynamicColors.primaryContainer.tone(s), 4.5);
            }
            if (isMonochrome(s)) {
                return s.isDark ? 0 : 100;
            }
            return s.isDark ? 90 : 10;
        },
        background: (s) => MaterialDynamicColors.primaryContainer,
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21),
    });
    MaterialDynamicColors.inversePrimary = DynamicColor.fromPalette({
        name: 'inverse_primary',
        palette: (s) => s.primaryPalette,
        tone: (s) => s.isDark ? 40 : 80,
        background: (s) => MaterialDynamicColors.inverseSurface,
        contrastCurve: new ContrastCurve(3, 4.5, 7, 11),
    });
    MaterialDynamicColors.secondary = DynamicColor.fromPalette({
        name: 'secondary',
        palette: (s) => s.secondaryPalette,
        tone: (s) => s.isDark ? 80 : 40,
        isBackground: true,
        background: (s) => MaterialDynamicColors.highestSurface(s),
        contrastCurve: new ContrastCurve(3, 4.5, 7, 11),
        toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.secondaryContainer, MaterialDynamicColors.secondary, 15, 'nearer', false),
    });
    MaterialDynamicColors.onSecondary = DynamicColor.fromPalette({
        name: 'on_secondary',
        palette: (s) => s.secondaryPalette,
        tone: (s) => {
            if (isMonochrome(s)) {
                return s.isDark ? 10 : 100;
            }
            else {
                return s.isDark ? 20 : 100;
            }
        },
        background: (s) => MaterialDynamicColors.secondary,
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21),
    });
    MaterialDynamicColors.secondaryContainer = DynamicColor.fromPalette({
        name: 'secondary_container',
        palette: (s) => s.secondaryPalette,
        tone: (s) => {
            const initialTone = s.isDark ? 30 : 90;
            if (isMonochrome(s)) {
                return s.isDark ? 30 : 85;
            }
            if (!isFidelity(s)) {
                return initialTone;
            }
            let answer = findDesiredChromaByTone(s.secondaryPalette.hue, s.secondaryPalette.chroma, initialTone, s.isDark ? false : true);
            answer = performAlbers(s.secondaryPalette.getHct(answer), s);
            return answer;
        },
        isBackground: true,
        background: (s) => MaterialDynamicColors.highestSurface(s),
        contrastCurve: new ContrastCurve(1, 1, 3, 7),
        toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.secondaryContainer, MaterialDynamicColors.secondary, 15, 'nearer', false),
    });
    MaterialDynamicColors.onSecondaryContainer = DynamicColor.fromPalette({
        name: 'on_secondary_container',
        palette: (s) => s.secondaryPalette,
        tone: (s) => {
            if (!isFidelity(s)) {
                return s.isDark ? 90 : 10;
            }
            return DynamicColor.foregroundTone(MaterialDynamicColors.secondaryContainer.tone(s), 4.5);
        },
        background: (s) => MaterialDynamicColors.secondaryContainer,
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21),
    });
    MaterialDynamicColors.tertiary = DynamicColor.fromPalette({
        name: 'tertiary',
        palette: (s) => s.tertiaryPalette,
        tone: (s) => {
            if (isMonochrome(s)) {
                return s.isDark ? 90 : 25;
            }
            return s.isDark ? 80 : 40;
        },
        isBackground: true,
        background: (s) => MaterialDynamicColors.highestSurface(s),
        contrastCurve: new ContrastCurve(3, 4.5, 7, 11),
        toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.tertiaryContainer, MaterialDynamicColors.tertiary, 15, 'nearer', false),
    });
    MaterialDynamicColors.onTertiary = DynamicColor.fromPalette({
        name: 'on_tertiary',
        palette: (s) => s.tertiaryPalette,
        tone: (s) => {
            if (isMonochrome(s)) {
                return s.isDark ? 10 : 90;
            }
            return s.isDark ? 20 : 100;
        },
        background: (s) => MaterialDynamicColors.tertiary,
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21),
    });
    MaterialDynamicColors.tertiaryContainer = DynamicColor.fromPalette({
        name: 'tertiary_container',
        palette: (s) => s.tertiaryPalette,
        tone: (s) => {
            if (isMonochrome(s)) {
                return s.isDark ? 60 : 49;
            }
            if (!isFidelity(s)) {
                return s.isDark ? 30 : 90;
            }
            const albersTone = performAlbers(s.tertiaryPalette.getHct(s.sourceColorHct.tone), s);
            const proposedHct = s.tertiaryPalette.getHct(albersTone);
            return DislikeAnalyzer.fixIfDisliked(proposedHct).tone;
        },
        isBackground: true,
        background: (s) => MaterialDynamicColors.highestSurface(s),
        contrastCurve: new ContrastCurve(1, 1, 3, 7),
        toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.tertiaryContainer, MaterialDynamicColors.tertiary, 15, 'nearer', false),
    });
    MaterialDynamicColors.onTertiaryContainer = DynamicColor.fromPalette({
        name: 'on_tertiary_container',
        palette: (s) => s.tertiaryPalette,
        tone: (s) => {
            if (isMonochrome(s)) {
                return s.isDark ? 0 : 100;
            }
            if (!isFidelity(s)) {
                return s.isDark ? 90 : 10;
            }
            return DynamicColor.foregroundTone(MaterialDynamicColors.tertiaryContainer.tone(s), 4.5);
        },
        background: (s) => MaterialDynamicColors.tertiaryContainer,
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21),
    });
    MaterialDynamicColors.error = DynamicColor.fromPalette({
        name: 'error',
        palette: (s) => s.errorPalette,
        tone: (s) => s.isDark ? 80 : 40,
        isBackground: true,
        background: (s) => MaterialDynamicColors.highestSurface(s),
        contrastCurve: new ContrastCurve(3, 4.5, 7, 11),
        toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.errorContainer, MaterialDynamicColors.error, 15, 'nearer', false),
    });
    MaterialDynamicColors.onError = DynamicColor.fromPalette({
        name: 'on_error',
        palette: (s) => s.errorPalette,
        tone: (s) => s.isDark ? 20 : 100,
        background: (s) => MaterialDynamicColors.error,
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21),
    });
    MaterialDynamicColors.errorContainer = DynamicColor.fromPalette({
        name: 'error_container',
        palette: (s) => s.errorPalette,
        tone: (s) => s.isDark ? 30 : 90,
        isBackground: true,
        background: (s) => MaterialDynamicColors.highestSurface(s),
        contrastCurve: new ContrastCurve(1, 1, 3, 7),
        toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.errorContainer, MaterialDynamicColors.error, 15, 'nearer', false),
    });
    MaterialDynamicColors.onErrorContainer = DynamicColor.fromPalette({
        name: 'on_error_container',
        palette: (s) => s.errorPalette,
        tone: (s) => s.isDark ? 90 : 10,
        background: (s) => MaterialDynamicColors.errorContainer,
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21),
    });
    MaterialDynamicColors.primaryFixed = DynamicColor.fromPalette({
        name: 'primary_fixed',
        palette: (s) => s.primaryPalette,
        tone: (s) => isMonochrome(s) ? 40.0 : 90.0,
        isBackground: true,
        background: (s) => MaterialDynamicColors.highestSurface(s),
        contrastCurve: new ContrastCurve(1, 1, 3, 7),
        toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.primaryFixed, MaterialDynamicColors.primaryFixedDim, 10, 'lighter', true),
    });
    MaterialDynamicColors.primaryFixedDim = DynamicColor.fromPalette({
        name: 'primary_fixed_dim',
        palette: (s) => s.primaryPalette,
        tone: (s) => isMonochrome(s) ? 30.0 : 80.0,
        isBackground: true,
        background: (s) => MaterialDynamicColors.highestSurface(s),
        contrastCurve: new ContrastCurve(1, 1, 3, 7),
        toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.primaryFixed, MaterialDynamicColors.primaryFixedDim, 10, 'lighter', true),
    });
    MaterialDynamicColors.onPrimaryFixed = DynamicColor.fromPalette({
        name: 'on_primary_fixed',
        palette: (s) => s.primaryPalette,
        tone: (s) => isMonochrome(s) ? 100.0 : 10.0,
        background: (s) => MaterialDynamicColors.primaryFixedDim,
        secondBackground: (s) => MaterialDynamicColors.primaryFixed,
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21),
    });
    MaterialDynamicColors.onPrimaryFixedVariant = DynamicColor.fromPalette({
        name: 'on_primary_fixed_variant',
        palette: (s) => s.primaryPalette,
        tone: (s) => isMonochrome(s) ? 90.0 : 30.0,
        background: (s) => MaterialDynamicColors.primaryFixedDim,
        secondBackground: (s) => MaterialDynamicColors.primaryFixed,
        contrastCurve: new ContrastCurve(3, 4.5, 7, 11),
    });
    MaterialDynamicColors.secondaryFixed = DynamicColor.fromPalette({
        name: 'secondary_fixed',
        palette: (s) => s.secondaryPalette,
        tone: (s) => isMonochrome(s) ? 80.0 : 90.0,
        isBackground: true,
        background: (s) => MaterialDynamicColors.highestSurface(s),
        contrastCurve: new ContrastCurve(1, 1, 3, 7),
        toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.secondaryFixed, MaterialDynamicColors.secondaryFixedDim, 10, 'lighter', true),
    });
    MaterialDynamicColors.secondaryFixedDim = DynamicColor.fromPalette({
        name: 'secondary_fixed_dim',
        palette: (s) => s.secondaryPalette,
        tone: (s) => isMonochrome(s) ? 70.0 : 80.0,
        isBackground: true,
        background: (s) => MaterialDynamicColors.highestSurface(s),
        contrastCurve: new ContrastCurve(1, 1, 3, 7),
        toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.secondaryFixed, MaterialDynamicColors.secondaryFixedDim, 10, 'lighter', true),
    });
    MaterialDynamicColors.onSecondaryFixed = DynamicColor.fromPalette({
        name: 'on_secondary_fixed',
        palette: (s) => s.secondaryPalette,
        tone: (s) => 10.0,
        background: (s) => MaterialDynamicColors.secondaryFixedDim,
        secondBackground: (s) => MaterialDynamicColors.secondaryFixed,
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21),
    });
    MaterialDynamicColors.onSecondaryFixedVariant = DynamicColor.fromPalette({
        name: 'on_secondary_fixed_variant',
        palette: (s) => s.secondaryPalette,
        tone: (s) => isMonochrome(s) ? 25.0 : 30.0,
        background: (s) => MaterialDynamicColors.secondaryFixedDim,
        secondBackground: (s) => MaterialDynamicColors.secondaryFixed,
        contrastCurve: new ContrastCurve(3, 4.5, 7, 11),
    });
    MaterialDynamicColors.tertiaryFixed = DynamicColor.fromPalette({
        name: 'tertiary_fixed',
        palette: (s) => s.tertiaryPalette,
        tone: (s) => isMonochrome(s) ? 40.0 : 90.0,
        isBackground: true,
        background: (s) => MaterialDynamicColors.highestSurface(s),
        contrastCurve: new ContrastCurve(1, 1, 3, 7),
        toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.tertiaryFixed, MaterialDynamicColors.tertiaryFixedDim, 10, 'lighter', true),
    });
    MaterialDynamicColors.tertiaryFixedDim = DynamicColor.fromPalette({
        name: 'tertiary_fixed_dim',
        palette: (s) => s.tertiaryPalette,
        tone: (s) => isMonochrome(s) ? 30.0 : 80.0,
        isBackground: true,
        background: (s) => MaterialDynamicColors.highestSurface(s),
        contrastCurve: new ContrastCurve(1, 1, 3, 7),
        toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.tertiaryFixed, MaterialDynamicColors.tertiaryFixedDim, 10, 'lighter', true),
    });
    MaterialDynamicColors.onTertiaryFixed = DynamicColor.fromPalette({
        name: 'on_tertiary_fixed',
        palette: (s) => s.tertiaryPalette,
        tone: (s) => isMonochrome(s) ? 100.0 : 10.0,
        background: (s) => MaterialDynamicColors.tertiaryFixedDim,
        secondBackground: (s) => MaterialDynamicColors.tertiaryFixed,
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21),
    });
    MaterialDynamicColors.onTertiaryFixedVariant = DynamicColor.fromPalette({
        name: 'on_tertiary_fixed_variant',
        palette: (s) => s.tertiaryPalette,
        tone: (s) => isMonochrome(s) ? 90.0 : 30.0,
        background: (s) => MaterialDynamicColors.tertiaryFixedDim,
        secondBackground: (s) => MaterialDynamicColors.tertiaryFixed,
        contrastCurve: new ContrastCurve(3, 4.5, 7, 11),
    });

    /**
     * @license
     * Copyright 2021 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     *  A convenience class for retrieving colors that are constant in hue and
     *  chroma, but vary in tone.
     */
    class TonalPalette {
        /**
         * @param argb ARGB representation of a color
         * @return Tones matching that color's hue and chroma.
         */
        static fromInt(argb) {
            const hct = Hct.fromInt(argb);
            return TonalPalette.fromHct(hct);
        }
        /**
         * @param hct Hct
         * @return Tones matching that color's hue and chroma.
         */
        static fromHct(hct) {
            return new TonalPalette(hct.hue, hct.chroma, hct);
        }
        /**
         * @param hue HCT hue
         * @param chroma HCT chroma
         * @return Tones matching hue and chroma.
         */
        static fromHueAndChroma(hue, chroma) {
            return new TonalPalette(hue, chroma, TonalPalette.createKeyColor(hue, chroma));
        }
        constructor(hue, chroma, keyColor) {
            this.hue = hue;
            this.chroma = chroma;
            this.keyColor = keyColor;
            this.cache = new Map();
        }
        static createKeyColor(hue, chroma) {
            const startTone = 50.0;
            let smallestDeltaHct = Hct.from(hue, chroma, startTone);
            let smallestDelta = Math.abs(smallestDeltaHct.chroma - chroma);
            // Starting from T50, check T+/-delta to see if they match the requested
            // chroma.
            //
            // Starts from T50 because T50 has the most chroma available, on
            // average. Thus it is most likely to have a direct answer and minimize
            // iteration.
            for (let delta = 1.0; delta < 50.0; delta += 1.0) {
                // Termination condition rounding instead of minimizing delta to avoid
                // case where requested chroma is 16.51, and the closest chroma is 16.49.
                // Error is minimized, but when rounded and displayed, requested chroma
                // is 17, key color's chroma is 16.
                if (Math.round(chroma) === Math.round(smallestDeltaHct.chroma)) {
                    return smallestDeltaHct;
                }
                const hctAdd = Hct.from(hue, chroma, startTone + delta);
                const hctAddDelta = Math.abs(hctAdd.chroma - chroma);
                if (hctAddDelta < smallestDelta) {
                    smallestDelta = hctAddDelta;
                    smallestDeltaHct = hctAdd;
                }
                const hctSubtract = Hct.from(hue, chroma, startTone - delta);
                const hctSubtractDelta = Math.abs(hctSubtract.chroma - chroma);
                if (hctSubtractDelta < smallestDelta) {
                    smallestDelta = hctSubtractDelta;
                    smallestDeltaHct = hctSubtract;
                }
            }
            return smallestDeltaHct;
        }
        /**
         * @param tone HCT tone, measured from 0 to 100.
         * @return ARGB representation of a color with that tone.
         */
        tone(tone) {
            let argb = this.cache.get(tone);
            if (argb === undefined) {
                argb = Hct.from(this.hue, this.chroma, tone).toInt();
                this.cache.set(tone, argb);
            }
            return argb;
        }
        /**
         * @param tone HCT tone.
         * @return HCT representation of a color with that tone.
         */
        getHct(tone) {
            return Hct.fromInt(this.tone(tone));
        }
    }

    /**
     * @license
     * Copyright 2021 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * An intermediate concept between the key color for a UI theme, and a full
     * color scheme. 5 sets of tones are generated, all except one use the same hue
     * as the key color, and all vary in chroma.
     */
    class CorePalette {
        /**
         * @param argb ARGB representation of a color
         */
        static of(argb) {
            return new CorePalette(argb, false);
        }
        /**
         * @param argb ARGB representation of a color
         */
        static contentOf(argb) {
            return new CorePalette(argb, true);
        }
        /**
         * Create a [CorePalette] from a set of colors
         */
        static fromColors(colors) {
            return CorePalette.createPaletteFromColors(false, colors);
        }
        /**
         * Create a content [CorePalette] from a set of colors
         */
        static contentFromColors(colors) {
            return CorePalette.createPaletteFromColors(true, colors);
        }
        static createPaletteFromColors(content, colors) {
            const palette = new CorePalette(colors.primary, content);
            if (colors.secondary) {
                const p = new CorePalette(colors.secondary, content);
                palette.a2 = p.a1;
            }
            if (colors.tertiary) {
                const p = new CorePalette(colors.tertiary, content);
                palette.a3 = p.a1;
            }
            if (colors.error) {
                const p = new CorePalette(colors.error, content);
                palette.error = p.a1;
            }
            if (colors.neutral) {
                const p = new CorePalette(colors.neutral, content);
                palette.n1 = p.n1;
            }
            if (colors.neutralVariant) {
                const p = new CorePalette(colors.neutralVariant, content);
                palette.n2 = p.n2;
            }
            return palette;
        }
        constructor(argb, isContent) {
            const hct = Hct.fromInt(argb);
            const hue = hct.hue;
            const chroma = hct.chroma;
            if (isContent) {
                this.a1 = TonalPalette.fromHueAndChroma(hue, chroma);
                this.a2 = TonalPalette.fromHueAndChroma(hue, chroma / 3);
                this.a3 = TonalPalette.fromHueAndChroma(hue + 60, chroma / 2);
                this.n1 = TonalPalette.fromHueAndChroma(hue, Math.min(chroma / 12, 4));
                this.n2 = TonalPalette.fromHueAndChroma(hue, Math.min(chroma / 6, 8));
            }
            else {
                this.a1 = TonalPalette.fromHueAndChroma(hue, Math.max(48, chroma));
                this.a2 = TonalPalette.fromHueAndChroma(hue, 16);
                this.a3 = TonalPalette.fromHueAndChroma(hue + 60, 24);
                this.n1 = TonalPalette.fromHueAndChroma(hue, 4);
                this.n2 = TonalPalette.fromHueAndChroma(hue, 8);
            }
            this.error = TonalPalette.fromHueAndChroma(25, 84);
        }
    }

    /**
     * @license
     * Copyright 2021 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // This file is automatically generated. Do not modify it.
    /**
     * Represents a Material color scheme, a mapping of color roles to colors.
     */
    class Scheme {
        get primary() {
            return this.props.primary;
        }
        get onPrimary() {
            return this.props.onPrimary;
        }
        get primaryContainer() {
            return this.props.primaryContainer;
        }
        get onPrimaryContainer() {
            return this.props.onPrimaryContainer;
        }
        get secondary() {
            return this.props.secondary;
        }
        get onSecondary() {
            return this.props.onSecondary;
        }
        get secondaryContainer() {
            return this.props.secondaryContainer;
        }
        get onSecondaryContainer() {
            return this.props.onSecondaryContainer;
        }
        get tertiary() {
            return this.props.tertiary;
        }
        get onTertiary() {
            return this.props.onTertiary;
        }
        get tertiaryContainer() {
            return this.props.tertiaryContainer;
        }
        get onTertiaryContainer() {
            return this.props.onTertiaryContainer;
        }
        get error() {
            return this.props.error;
        }
        get onError() {
            return this.props.onError;
        }
        get errorContainer() {
            return this.props.errorContainer;
        }
        get onErrorContainer() {
            return this.props.onErrorContainer;
        }
        get background() {
            return this.props.background;
        }
        get onBackground() {
            return this.props.onBackground;
        }
        get surface() {
            return this.props.surface;
        }
        get onSurface() {
            return this.props.onSurface;
        }
        get surfaceVariant() {
            return this.props.surfaceVariant;
        }
        get onSurfaceVariant() {
            return this.props.onSurfaceVariant;
        }
        get outline() {
            return this.props.outline;
        }
        get outlineVariant() {
            return this.props.outlineVariant;
        }
        get shadow() {
            return this.props.shadow;
        }
        get scrim() {
            return this.props.scrim;
        }
        get inverseSurface() {
            return this.props.inverseSurface;
        }
        get inverseOnSurface() {
            return this.props.inverseOnSurface;
        }
        get inversePrimary() {
            return this.props.inversePrimary;
        }
        /**
         * @param argb ARGB representation of a color.
         * @return Light Material color scheme, based on the color's hue.
         */
        static light(argb) {
            return Scheme.lightFromCorePalette(CorePalette.of(argb));
        }
        /**
         * @param argb ARGB representation of a color.
         * @return Dark Material color scheme, based on the color's hue.
         */
        static dark(argb) {
            return Scheme.darkFromCorePalette(CorePalette.of(argb));
        }
        /**
         * @param argb ARGB representation of a color.
         * @return Light Material content color scheme, based on the color's hue.
         */
        static lightContent(argb) {
            return Scheme.lightFromCorePalette(CorePalette.contentOf(argb));
        }
        /**
         * @param argb ARGB representation of a color.
         * @return Dark Material content color scheme, based on the color's hue.
         */
        static darkContent(argb) {
            return Scheme.darkFromCorePalette(CorePalette.contentOf(argb));
        }
        /**
         * Light scheme from core palette
         */
        static lightFromCorePalette(core) {
            return new Scheme({
                primary: core.a1.tone(40),
                onPrimary: core.a1.tone(100),
                primaryContainer: core.a1.tone(90),
                onPrimaryContainer: core.a1.tone(10),
                secondary: core.a2.tone(40),
                onSecondary: core.a2.tone(100),
                secondaryContainer: core.a2.tone(90),
                onSecondaryContainer: core.a2.tone(10),
                tertiary: core.a3.tone(40),
                onTertiary: core.a3.tone(100),
                tertiaryContainer: core.a3.tone(90),
                onTertiaryContainer: core.a3.tone(10),
                error: core.error.tone(40),
                onError: core.error.tone(100),
                errorContainer: core.error.tone(90),
                onErrorContainer: core.error.tone(10),
                background: core.n1.tone(99),
                onBackground: core.n1.tone(10),
                surface: core.n1.tone(99),
                onSurface: core.n1.tone(10),
                surfaceVariant: core.n2.tone(90),
                onSurfaceVariant: core.n2.tone(30),
                outline: core.n2.tone(50),
                outlineVariant: core.n2.tone(80),
                shadow: core.n1.tone(0),
                scrim: core.n1.tone(0),
                inverseSurface: core.n1.tone(20),
                inverseOnSurface: core.n1.tone(95),
                inversePrimary: core.a1.tone(80)
            });
        }
        /**
         * Dark scheme from core palette
         */
        static darkFromCorePalette(core) {
            return new Scheme({
                primary: core.a1.tone(80),
                onPrimary: core.a1.tone(20),
                primaryContainer: core.a1.tone(30),
                onPrimaryContainer: core.a1.tone(90),
                secondary: core.a2.tone(80),
                onSecondary: core.a2.tone(20),
                secondaryContainer: core.a2.tone(30),
                onSecondaryContainer: core.a2.tone(90),
                tertiary: core.a3.tone(80),
                onTertiary: core.a3.tone(20),
                tertiaryContainer: core.a3.tone(30),
                onTertiaryContainer: core.a3.tone(90),
                error: core.error.tone(80),
                onError: core.error.tone(20),
                errorContainer: core.error.tone(30),
                onErrorContainer: core.error.tone(80),
                background: core.n1.tone(10),
                onBackground: core.n1.tone(90),
                surface: core.n1.tone(10),
                onSurface: core.n1.tone(90),
                surfaceVariant: core.n2.tone(30),
                onSurfaceVariant: core.n2.tone(80),
                outline: core.n2.tone(60),
                outlineVariant: core.n2.tone(30),
                shadow: core.n1.tone(0),
                scrim: core.n1.tone(0),
                inverseSurface: core.n1.tone(90),
                inverseOnSurface: core.n1.tone(20),
                inversePrimary: core.a1.tone(40)
            });
        }
        constructor(props) {
            this.props = props;
        }
        toJSON() {
            return {
                ...this.props
            };
        }
    }

    /**
     * @license
     * Copyright 2021 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Utility methods for hexadecimal representations of colors.
     */
    /**
     * @param argb ARGB representation of a color.
     * @return Hex string representing color, ex. #ff0000 for red.
     */
    function hexFromArgb(argb) {
        const r = redFromArgb(argb);
        const g = greenFromArgb(argb);
        const b = blueFromArgb(argb);
        const outParts = [r.toString(16), g.toString(16), b.toString(16)];
        // Pad single-digit output values
        for (const [i, part] of outParts.entries()) {
            if (part.length === 1) {
                outParts[i] = '0' + part;
            }
        }
        return '#' + outParts.join('');
    }
    /**
     * @param hex String representing color as hex code. Accepts strings with or
     *     without leading #, and string representing the color using 3, 6, or 8
     *     hex characters.
     * @return ARGB representation of color.
     */
    function argbFromHex(hex) {
        hex = hex.replace('#', '');
        const isThree = hex.length === 3;
        const isSix = hex.length === 6;
        const isEight = hex.length === 8;
        if (!isThree && !isSix && !isEight) {
            throw new Error('unexpected hex ' + hex);
        }
        let r = 0;
        let g = 0;
        let b = 0;
        if (isThree) {
            r = parseIntHex(hex.slice(0, 1).repeat(2));
            g = parseIntHex(hex.slice(1, 2).repeat(2));
            b = parseIntHex(hex.slice(2, 3).repeat(2));
        }
        else if (isSix) {
            r = parseIntHex(hex.slice(0, 2));
            g = parseIntHex(hex.slice(2, 4));
            b = parseIntHex(hex.slice(4, 6));
        }
        else if (isEight) {
            r = parseIntHex(hex.slice(2, 4));
            g = parseIntHex(hex.slice(4, 6));
            b = parseIntHex(hex.slice(6, 8));
        }
        return (((255 << 24) | ((r & 0x0ff) << 16) | ((g & 0x0ff) << 8) | (b & 0x0ff)) >>>
            0);
    }
    function parseIntHex(value) {
        // tslint:disable-next-line:ban
        return parseInt(value, 16);
    }

    /**
     * @license
     * Copyright 2021 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Generate custom color group from source and target color
     *
     * @param source Source color
     * @param color Custom color
     * @return Custom color group
     *
     * @link https://m3.material.io/styles/color/the-color-system/color-roles
     */
    function customColor(source, color) {
        let value = color.value;
        const from = value;
        const to = source;
        if (color.blend) {
            value = Blend.harmonize(from, to);
        }
        const palette = CorePalette.of(value);
        const tones = palette.a1;
        return {
            color,
            value,
            light: {
                color: tones.tone(40),
                onColor: tones.tone(100),
                colorContainer: tones.tone(90),
                onColorContainer: tones.tone(10),
            },
            dark: {
                color: tones.tone(80),
                onColor: tones.tone(20),
                colorContainer: tones.tone(30),
                onColorContainer: tones.tone(90),
            },
        };
    }

    var w = Object.defineProperty;
    var F = (n, r, e) => r in n ? w(n, r, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[r] = e;
    var u = (n, r, e) => (F(n, typeof r != "symbol" ? r + "" : r, e), e);
    const g = (n, r, e = "", t) => {
      for (const [a, c] of Object.entries(r.toJSON())) {
        const f = a.replaceAll(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), h = t === "rgb" ? Object.values(rgbaFromArgb(c)).slice(0, -1).join(" ") : hexFromArgb(c);
        n.style.setProperty(`--md-sys-color-${f}${e}`, h);
      }
    }, T = (n, r) => {
      const e = (r == null ? void 0 : r.target) || document.body, a = (r == null ? void 0 : r.dark) ?? !1 ? n.schemes.dark : n.schemes.light;
      if (r != null && r.brightnessSuffix ? (g(e, n.schemes.dark, "-dark", r == null ? void 0 : r.colorFormat), g(e, n.schemes.light, "-light", r == null ? void 0 : r.colorFormat)) : g(e, a, "", r == null ? void 0 : r.colorFormat), r != null && r.paletteTones) {
        const c = (r == null ? void 0 : r.paletteTones) ?? [];
        for (const [f, h] of Object.entries(n.palettes)) {
          const d = f.replaceAll(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
          for (const m of c) {
            const y = `--md-ref-palette-${d}${m}`, k = (r == null ? void 0 : r.colorFormat) === "rgb" ? Object.values(rgbaFromArgb(h.tone(m))).slice(0, -1).join(" ") : hexFromArgb(h.tone(m));
            e.style.setProperty(y, k);
          }
        }
      }
    };
    class s {
      constructor(r, e) {
        /** primary */
        u(this, "a1");
        /** secondary */
        u(this, "a2");
        /** tertiary */
        u(this, "a3");
        /** neutral */
        u(this, "n1");
        /** neutralVariant */
        u(this, "n2");
        /** error */
        u(this, "error");
        const { hue: t, chroma: a } = Hct.fromInt(r);
        e ? (this.a1 = TonalPalette.fromHueAndChroma(t, a), this.a2 = TonalPalette.fromHueAndChroma(t, a / 3), this.a3 = TonalPalette.fromHueAndChroma(t + 60, a / 2), this.n1 = TonalPalette.fromHueAndChroma(t, Math.min(a / 12, 4)), this.n2 = TonalPalette.fromHueAndChroma(t, Math.min(a / 6, 8))) : (this.a1 = TonalPalette.fromHueAndChroma(t, Math.max(48, a)), this.a2 = TonalPalette.fromHueAndChroma(t, 16), this.a3 = TonalPalette.fromHueAndChroma(t + 60, 24), this.n1 = TonalPalette.fromHueAndChroma(t, 6), this.n2 = TonalPalette.fromHueAndChroma(t, 8)), this.error = TonalPalette.fromHueAndChroma(25, 84);
      }
      static of(r) {
        return new s(r, !1);
      }
      static contentOf(r) {
        return new s(r, !0);
      }
      static fromColors(r) {
        return s.createPaletteFromColors(!1, r);
      }
      static contentFromColors(r) {
        return s.createPaletteFromColors(!0, r);
      }
      static createPaletteFromColors(r, e) {
        const t = new s(e.primary, r);
        if (e.secondary) {
          const a = new s(e.secondary, r);
          t.a2 = a.a1;
        }
        if (e.tertiary) {
          const a = new s(e.tertiary, r);
          t.a3 = a.a1;
        }
        if (e.error) {
          const a = new s(e.error, r);
          t.error = a.a1;
        }
        if (e.neutral) {
          const a = new s(e.neutral, r);
          t.n1 = a.n1;
        }
        if (e.neutralVariant) {
          const a = new s(e.neutralVariant, r);
          t.n2 = a.n2;
        }
        return t;
      }
    }
    class i {
      // eslint-disable-next-line no-useless-constructor, unicorn/prevent-abbreviations
      constructor(r) {
        this.props = r;
      }
      get primary() {
        return this.props.primary;
      }
      get onPrimary() {
        return this.props.onPrimary;
      }
      get primaryContainer() {
        return this.props.primaryContainer;
      }
      get onPrimaryContainer() {
        return this.props.onPrimaryContainer;
      }
      get secondary() {
        return this.props.secondary;
      }
      get onSecondary() {
        return this.props.onSecondary;
      }
      get secondaryContainer() {
        return this.props.secondaryContainer;
      }
      get onSecondaryContainer() {
        return this.props.onSecondaryContainer;
      }
      get tertiary() {
        return this.props.tertiary;
      }
      get onTertiary() {
        return this.props.onTertiary;
      }
      get tertiaryContainer() {
        return this.props.tertiaryContainer;
      }
      get onTertiaryContainer() {
        return this.props.onTertiaryContainer;
      }
      get error() {
        return this.props.error;
      }
      get onError() {
        return this.props.onError;
      }
      get errorContainer() {
        return this.props.errorContainer;
      }
      get onErrorContainer() {
        return this.props.onErrorContainer;
      }
      get background() {
        return this.props.background;
      }
      get onBackground() {
        return this.props.onBackground;
      }
      get surface() {
        return this.props.surface;
      }
      get onSurface() {
        return this.props.onSurface;
      }
      get surfaceVariant() {
        return this.props.surfaceVariant;
      }
      get onSurfaceVariant() {
        return this.props.onSurfaceVariant;
      }
      get outline() {
        return this.props.outline;
      }
      get outlineVariant() {
        return this.props.outlineVariant;
      }
      get shadow() {
        return this.props.shadow;
      }
      get scrim() {
        return this.props.scrim;
      }
      get inverseSurface() {
        return this.props.inverseSurface;
      }
      get inverseOnSurface() {
        return this.props.inverseOnSurface;
      }
      get inversePrimary() {
        return this.props.inversePrimary;
      }
      /** extra */
      get surfaceBright() {
        return this.props.surfaceBright;
      }
      /** extra */
      get surfaceContainer() {
        return this.props.surfaceContainer;
      }
      /** extra */
      get surfaceContainerHigh() {
        return this.props.surfaceContainerHigh;
      }
      /** extra */
      get surfaceContainerHighest() {
        return this.props.surfaceContainerHighest;
      }
      /** extra */
      get surfaceContainerLow() {
        return this.props.surfaceContainerLow;
      }
      /** extra */
      get surfaceContainerLowest() {
        return this.props.surfaceContainerLowest;
      }
      /** extra */
      get surfaceTint() {
        return this.props.surfaceTint;
      }
      static light(r) {
        return i.lightFromCorePalette(s.of(r));
      }
      static dark(r) {
        return i.darkFromCorePalette(s.of(r));
      }
      static lightContent(r) {
        return i.lightFromCorePalette(s.contentOf(r));
      }
      static darkContent(r) {
        return i.darkFromCorePalette(s.contentOf(r));
      }
      static lightFromCorePalette(r) {
        return new i({
          ...Scheme.lightFromCorePalette(r).toJSON(),
          /**
           * The default light theme surface role from tone 99 to tone 98
           * @see {@link https://material.io/blog/tone-based-surface-color-m3}
           * @see {@link https://m3.material.io/styles/color/the-color-system/tokens}
           */
          background: r.n1.tone(98),
          /**
           * The default light theme surface role from tone 99 to tone 98
           * @see {@link https://material.io/blog/tone-based-surface-color-m3}
           * @see {@link https://m3.material.io/styles/color/the-color-system/tokens}
           */
          surface: r.n1.tone(98),
          surfaceBright: r.n1.tone(98),
          surfaceContainer: r.n1.tone(94),
          surfaceContainerHigh: r.n1.tone(92),
          surfaceContainerHighest: r.n1.tone(90),
          surfaceContainerLow: r.n1.tone(96),
          surfaceContainerLowest: r.n1.tone(100),
          surfaceDim: r.n1.tone(87),
          /**
           * Equal to Primary
           * @see {@link https://m3.material.io/styles/color/the-color-system/tokens}
           */
          surfaceTint: r.a1.tone(40)
        });
      }
      static darkFromCorePalette(r) {
        return new i({
          ...Scheme.darkFromCorePalette(r).toJSON(),
          /**
           * @see {@link https://github.com/material-foundation/material-color-utilities/issues/62}
           */
          onErrorContainer: r.error.tone(90),
          /* eslint-disable sort-keys-fix/sort-keys-fix */
          /**
           * Surface roles in dark theme are slightly darkened
           * @see {@link https://material.io/blog/tone-based-surface-color-m3}
           * @see {@link https://m3.material.io/styles/color/the-color-system/tokens}
           */
          background: r.n1.tone(6),
          /* eslint-enable sort-keys-fix/sort-keys-fix */
          /**
           * Surface roles in dark theme are slightly darkened
           * @see {@link https://material.io/blog/tone-based-surface-color-m3}
           * @see {@link https://m3.material.io/styles/color/the-color-system/tokens}
           */
          surface: r.n1.tone(6),
          surfaceBright: r.n1.tone(24),
          surfaceContainer: r.n1.tone(12),
          surfaceContainerHigh: r.n1.tone(17),
          surfaceContainerHighest: r.n1.tone(22),
          surfaceContainerLow: r.n1.tone(10),
          surfaceContainerLowest: r.n1.tone(4),
          surfaceDim: r.n1.tone(6),
          /**
           * Equal to Primary
           * @see {@link https://m3.material.io/styles/color/the-color-system/tokens}
           */
          surfaceTint: r.a1.tone(80)
        });
      }
      toJSON() {
        return this.props;
      }
    }
    const b = (n, r = []) => {
      const e = s.of(n);
      return {
        customColors: r.map((t) => customColor(n, t)),
        palettes: {
          error: e.error,
          neutral: e.n1,
          neutralVariant: e.n2,
          primary: e.a1,
          secondary: e.a2,
          tertiary: e.a3
        },
        schemes: {
          dark: i.dark(n),
          light: i.light(n)
        },
        source: n
      };
    };

    // ThemeContext.js
    const defaultValues = {
        mode: "light",
        sourceColor: "#4400ee",
        scheme: b(argbFromHex("#4400ee")).schemes["light"],
        toggleMode: function () { },
        updateSourceColor: function (newColor) { },
    };
    const ThemeContext = React.createContext(defaultValues);
    function ThemeProvider({ children }) {
        const [mode, setMode] = React.useState("light");
        const [sourceColor, setSourceColor] = React.useState("#4400ee");
        const [scheme, setscheme] = React.useState(b(argbFromHex("#4400ee"), []).schemes["light"]); // Store the generated theme colors here
        const [theme, setTheme] = React.useState(b(argbFromHex("#4400ee"), []));
        const toggleMode = (utheme) => {
            setMode(utheme ? utheme : (prevTheme) => (prevTheme === "light" ? "dark" : "light"));
            setscheme(theme.schemes[utheme ? utheme : mode === "light" ? "dark" : "light"]);
        };
        const updateSourceColor = (newColor) => {
            setSourceColor(newColor);
            const generatedTheme = b(argbFromHex(newColor), []);
            setscheme(generatedTheme.schemes[mode]);
        };
        React.useEffect(() => {
            if (document !== undefined) {
                if (document.body !== undefined) {
                    T(theme, { target: document.body, dark: mode === "dark" });
                }
            }
        }, []);
        return (React.createElement(ThemeContext.Provider, { value: { mode, toggleMode, sourceColor, updateSourceColor, scheme } }, children));
    }
    function useTheme() {
        const context = React.useContext(ThemeContext);
        if (!context) {
            throw new Error("useTheme must be used within a ThemeProvider");
        }
        return context;
    }

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise, SuppressedError, Symbol */


    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    const InteractiveStateLayer = (_a) => {
        var props = __rest(_a, []);
        const { layerColorName, layerOpacity } = props, divProps = __rest(props, ["layerColorName", "layerOpacity"]);
        const { scheme } = useTheme();
        const InteractiveStateLayerStyles = {
            // backgroundColor: `#${scheme[props.layerColorName]}${(props.layerOpacity*256).toString(16).replace(".", "").padStart(2, '0').slice(0,2)}`,
            //backgroundColor: `#${scheme[props.layerColorName].toString(16)}`
            backgroundColor: `#${hexFromArgb(scheme[layerColorName])}${(layerOpacity * 256)
            .toString(16)
            .replace(".", "")
            .padStart(2, "0")
            .slice(0, 2)}`
        };
        return React.createElement("div", Object.assign({}, divProps, { style: InteractiveStateLayerStyles }));
    };
    const ColorSurface = (_a) => {
        var props = __rest(_a, []);
        const divProps = __rest(props, ["colorName"]);
        const { scheme } = useTheme();
        const ColorSurfaceStyles = {
            backgroundColor: hexFromArgb(scheme["primary"])
        };
        return React.createElement("div", Object.assign({}, divProps, { style: ColorSurfaceStyles }));
    };

    /*

    Based off glamor's StyleSheet, thanks Sunil 

    high performance StyleSheet for css-in-js systems

    - uses multiple style tags behind the scenes for millions of rules
    - uses `insertRule` for appending in production for *much* faster performance

    // usage

    import { StyleSheet } from '@emotion/sheet'

    let styleSheet = new StyleSheet({ key: '', container: document.head })

    styleSheet.insert('#box { border: 1px solid red; }')
    - appends a css rule into the stylesheet

    styleSheet.flush()
    - empties the stylesheet of all its contents

    */
    // $FlowFixMe
    function sheetForTag(tag) {
      if (tag.sheet) {
        // $FlowFixMe
        return tag.sheet;
      } // this weirdness brought to you by firefox

      /* istanbul ignore next */


      for (var i = 0; i < document.styleSheets.length; i++) {
        if (document.styleSheets[i].ownerNode === tag) {
          // $FlowFixMe
          return document.styleSheets[i];
        }
      }
    }

    function createStyleElement(options) {
      var tag = document.createElement('style');
      tag.setAttribute('data-emotion', options.key);

      if (options.nonce !== undefined) {
        tag.setAttribute('nonce', options.nonce);
      }

      tag.appendChild(document.createTextNode(''));
      tag.setAttribute('data-s', '');
      return tag;
    }

    var StyleSheet = /*#__PURE__*/function () {
      // Using Node instead of HTMLElement since container may be a ShadowRoot
      function StyleSheet(options) {
        var _this = this;

        this._insertTag = function (tag) {
          var before;

          if (_this.tags.length === 0) {
            if (_this.insertionPoint) {
              before = _this.insertionPoint.nextSibling;
            } else if (_this.prepend) {
              before = _this.container.firstChild;
            } else {
              before = _this.before;
            }
          } else {
            before = _this.tags[_this.tags.length - 1].nextSibling;
          }

          _this.container.insertBefore(tag, before);

          _this.tags.push(tag);
        };

        this.isSpeedy = options.speedy === undefined ? process.env.NODE_ENV === 'production' : options.speedy;
        this.tags = [];
        this.ctr = 0;
        this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

        this.key = options.key;
        this.container = options.container;
        this.prepend = options.prepend;
        this.insertionPoint = options.insertionPoint;
        this.before = null;
      }

      var _proto = StyleSheet.prototype;

      _proto.hydrate = function hydrate(nodes) {
        nodes.forEach(this._insertTag);
      };

      _proto.insert = function insert(rule) {
        // the max length is how many rules we have per style tag, it's 65000 in speedy mode
        // it's 1 in dev because we insert source maps that map a single rule to a location
        // and you can only have one source map per style tag
        if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
          this._insertTag(createStyleElement(this));
        }

        var tag = this.tags[this.tags.length - 1];

        if (process.env.NODE_ENV !== 'production') {
          var isImportRule = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;

          if (isImportRule && this._alreadyInsertedOrderInsensitiveRule) {
            // this would only cause problem in speedy mode
            // but we don't want enabling speedy to affect the observable behavior
            // so we report this error at all times
            console.error("You're attempting to insert the following rule:\n" + rule + '\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.');
          }
          this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule;
        }

        if (this.isSpeedy) {
          var sheet = sheetForTag(tag);

          try {
            // this is the ultrafast version, works across browsers
            // the big drawback is that the css won't be editable in devtools
            sheet.insertRule(rule, sheet.cssRules.length);
          } catch (e) {
            if (process.env.NODE_ENV !== 'production' && !/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {
              console.error("There was a problem inserting the following rule: \"" + rule + "\"", e);
            }
          }
        } else {
          tag.appendChild(document.createTextNode(rule));
        }

        this.ctr++;
      };

      _proto.flush = function flush() {
        // $FlowFixMe
        this.tags.forEach(function (tag) {
          return tag.parentNode && tag.parentNode.removeChild(tag);
        });
        this.tags = [];
        this.ctr = 0;

        if (process.env.NODE_ENV !== 'production') {
          this._alreadyInsertedOrderInsensitiveRule = false;
        }
      };

      return StyleSheet;
    }();

    var MS = '-ms-';
    var MOZ = '-moz-';
    var WEBKIT = '-webkit-';

    var COMMENT = 'comm';
    var RULESET = 'rule';
    var DECLARATION = 'decl';
    var IMPORT = '@import';
    var KEYFRAMES = '@keyframes';
    var LAYER = '@layer';

    /**
     * @param {number}
     * @return {number}
     */
    var abs = Math.abs;

    /**
     * @param {number}
     * @return {string}
     */
    var from = String.fromCharCode;

    /**
     * @param {object}
     * @return {object}
     */
    var assign = Object.assign;

    /**
     * @param {string} value
     * @param {number} length
     * @return {number}
     */
    function hash (value, length) {
    	return charat(value, 0) ^ 45 ? (((((((length << 2) ^ charat(value, 0)) << 2) ^ charat(value, 1)) << 2) ^ charat(value, 2)) << 2) ^ charat(value, 3) : 0
    }

    /**
     * @param {string} value
     * @return {string}
     */
    function trim (value) {
    	return value.trim()
    }

    /**
     * @param {string} value
     * @param {RegExp} pattern
     * @return {string?}
     */
    function match (value, pattern) {
    	return (value = pattern.exec(value)) ? value[0] : value
    }

    /**
     * @param {string} value
     * @param {(string|RegExp)} pattern
     * @param {string} replacement
     * @return {string}
     */
    function replace (value, pattern, replacement) {
    	return value.replace(pattern, replacement)
    }

    /**
     * @param {string} value
     * @param {string} search
     * @return {number}
     */
    function indexof (value, search) {
    	return value.indexOf(search)
    }

    /**
     * @param {string} value
     * @param {number} index
     * @return {number}
     */
    function charat (value, index) {
    	return value.charCodeAt(index) | 0
    }

    /**
     * @param {string} value
     * @param {number} begin
     * @param {number} end
     * @return {string}
     */
    function substr (value, begin, end) {
    	return value.slice(begin, end)
    }

    /**
     * @param {string} value
     * @return {number}
     */
    function strlen (value) {
    	return value.length
    }

    /**
     * @param {any[]} value
     * @return {number}
     */
    function sizeof (value) {
    	return value.length
    }

    /**
     * @param {any} value
     * @param {any[]} array
     * @return {any}
     */
    function append (value, array) {
    	return array.push(value), value
    }

    /**
     * @param {string[]} array
     * @param {function} callback
     * @return {string}
     */
    function combine (array, callback) {
    	return array.map(callback).join('')
    }

    var line = 1;
    var column = 1;
    var length = 0;
    var position = 0;
    var character = 0;
    var characters = '';

    /**
     * @param {string} value
     * @param {object | null} root
     * @param {object | null} parent
     * @param {string} type
     * @param {string[] | string} props
     * @param {object[] | string} children
     * @param {number} length
     */
    function node (value, root, parent, type, props, children, length) {
    	return {value: value, root: root, parent: parent, type: type, props: props, children: children, line: line, column: column, length: length, return: ''}
    }

    /**
     * @param {object} root
     * @param {object} props
     * @return {object}
     */
    function copy (root, props) {
    	return assign(node('', null, null, '', null, null, 0), root, {length: -root.length}, props)
    }

    /**
     * @return {number}
     */
    function char () {
    	return character
    }

    /**
     * @return {number}
     */
    function prev () {
    	character = position > 0 ? charat(characters, --position) : 0;

    	if (column--, character === 10)
    		column = 1, line--;

    	return character
    }

    /**
     * @return {number}
     */
    function next () {
    	character = position < length ? charat(characters, position++) : 0;

    	if (column++, character === 10)
    		column = 1, line++;

    	return character
    }

    /**
     * @return {number}
     */
    function peek () {
    	return charat(characters, position)
    }

    /**
     * @return {number}
     */
    function caret () {
    	return position
    }

    /**
     * @param {number} begin
     * @param {number} end
     * @return {string}
     */
    function slice (begin, end) {
    	return substr(characters, begin, end)
    }

    /**
     * @param {number} type
     * @return {number}
     */
    function token (type) {
    	switch (type) {
    		// \0 \t \n \r \s whitespace token
    		case 0: case 9: case 10: case 13: case 32:
    			return 5
    		// ! + , / > @ ~ isolate token
    		case 33: case 43: case 44: case 47: case 62: case 64: case 126:
    		// ; { } breakpoint token
    		case 59: case 123: case 125:
    			return 4
    		// : accompanied token
    		case 58:
    			return 3
    		// " ' ( [ opening delimit token
    		case 34: case 39: case 40: case 91:
    			return 2
    		// ) ] closing delimit token
    		case 41: case 93:
    			return 1
    	}

    	return 0
    }

    /**
     * @param {string} value
     * @return {any[]}
     */
    function alloc (value) {
    	return line = column = 1, length = strlen(characters = value), position = 0, []
    }

    /**
     * @param {any} value
     * @return {any}
     */
    function dealloc (value) {
    	return characters = '', value
    }

    /**
     * @param {number} type
     * @return {string}
     */
    function delimit (type) {
    	return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)))
    }

    /**
     * @param {number} type
     * @return {string}
     */
    function whitespace (type) {
    	while (character = peek())
    		if (character < 33)
    			next();
    		else
    			break

    	return token(type) > 2 || token(character) > 3 ? '' : ' '
    }

    /**
     * @param {number} index
     * @param {number} count
     * @return {string}
     */
    function escaping (index, count) {
    	while (--count && next())
    		// not 0-9 A-F a-f
    		if (character < 48 || character > 102 || (character > 57 && character < 65) || (character > 70 && character < 97))
    			break

    	return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32))
    }

    /**
     * @param {number} type
     * @return {number}
     */
    function delimiter (type) {
    	while (next())
    		switch (character) {
    			// ] ) " '
    			case type:
    				return position
    			// " '
    			case 34: case 39:
    				if (type !== 34 && type !== 39)
    					delimiter(character);
    				break
    			// (
    			case 40:
    				if (type === 41)
    					delimiter(type);
    				break
    			// \
    			case 92:
    				next();
    				break
    		}

    	return position
    }

    /**
     * @param {number} type
     * @param {number} index
     * @return {number}
     */
    function commenter (type, index) {
    	while (next())
    		// //
    		if (type + character === 47 + 10)
    			break
    		// /*
    		else if (type + character === 42 + 42 && peek() === 47)
    			break

    	return '/*' + slice(index, position - 1) + '*' + from(type === 47 ? type : next())
    }

    /**
     * @param {number} index
     * @return {string}
     */
    function identifier (index) {
    	while (!token(peek()))
    		next();

    	return slice(index, position)
    }

    /**
     * @param {string} value
     * @return {object[]}
     */
    function compile (value) {
    	return dealloc(parse('', null, null, null, [''], value = alloc(value), 0, [0], value))
    }

    /**
     * @param {string} value
     * @param {object} root
     * @param {object?} parent
     * @param {string[]} rule
     * @param {string[]} rules
     * @param {string[]} rulesets
     * @param {number[]} pseudo
     * @param {number[]} points
     * @param {string[]} declarations
     * @return {object}
     */
    function parse (value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
    	var index = 0;
    	var offset = 0;
    	var length = pseudo;
    	var atrule = 0;
    	var property = 0;
    	var previous = 0;
    	var variable = 1;
    	var scanning = 1;
    	var ampersand = 1;
    	var character = 0;
    	var type = '';
    	var props = rules;
    	var children = rulesets;
    	var reference = rule;
    	var characters = type;

    	while (scanning)
    		switch (previous = character, character = next()) {
    			// (
    			case 40:
    				if (previous != 108 && charat(characters, length - 1) == 58) {
    					if (indexof(characters += replace(delimit(character), '&', '&\f'), '&\f') != -1)
    						ampersand = -1;
    					break
    				}
    			// " ' [
    			case 34: case 39: case 91:
    				characters += delimit(character);
    				break
    			// \t \n \r \s
    			case 9: case 10: case 13: case 32:
    				characters += whitespace(previous);
    				break
    			// \
    			case 92:
    				characters += escaping(caret() - 1, 7);
    				continue
    			// /
    			case 47:
    				switch (peek()) {
    					case 42: case 47:
    						append(comment(commenter(next(), caret()), root, parent), declarations);
    						break
    					default:
    						characters += '/';
    				}
    				break
    			// {
    			case 123 * variable:
    				points[index++] = strlen(characters) * ampersand;
    			// } ; \0
    			case 125 * variable: case 59: case 0:
    				switch (character) {
    					// \0 }
    					case 0: case 125: scanning = 0;
    					// ;
    					case 59 + offset: if (ampersand == -1) characters = replace(characters, /\f/g, '');
    						if (property > 0 && (strlen(characters) - length))
    							append(property > 32 ? declaration(characters + ';', rule, parent, length - 1) : declaration(replace(characters, ' ', '') + ';', rule, parent, length - 2), declarations);
    						break
    					// @ ;
    					case 59: characters += ';';
    					// { rule/at-rule
    					default:
    						append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets);

    						if (character === 123)
    							if (offset === 0)
    								parse(characters, root, reference, reference, props, rulesets, length, points, children);
    							else
    								switch (atrule === 99 && charat(characters, 3) === 110 ? 100 : atrule) {
    									// d l m s
    									case 100: case 108: case 109: case 115:
    										parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children);
    										break
    									default:
    										parse(characters, reference, reference, reference, [''], children, 0, points, children);
    								}
    				}

    				index = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo;
    				break
    			// :
    			case 58:
    				length = 1 + strlen(characters), property = previous;
    			default:
    				if (variable < 1)
    					if (character == 123)
    						--variable;
    					else if (character == 125 && variable++ == 0 && prev() == 125)
    						continue

    				switch (characters += from(character), character * variable) {
    					// &
    					case 38:
    						ampersand = offset > 0 ? 1 : (characters += '\f', -1);
    						break
    					// ,
    					case 44:
    						points[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1;
    						break
    					// @
    					case 64:
    						// -
    						if (peek() === 45)
    							characters += delimit(next());

    						atrule = peek(), offset = length = strlen(type = characters += identifier(caret())), character++;
    						break
    					// -
    					case 45:
    						if (previous === 45 && strlen(characters) == 2)
    							variable = 0;
    				}
    		}

    	return rulesets
    }

    /**
     * @param {string} value
     * @param {object} root
     * @param {object?} parent
     * @param {number} index
     * @param {number} offset
     * @param {string[]} rules
     * @param {number[]} points
     * @param {string} type
     * @param {string[]} props
     * @param {string[]} children
     * @param {number} length
     * @return {object}
     */
    function ruleset (value, root, parent, index, offset, rules, points, type, props, children, length) {
    	var post = offset - 1;
    	var rule = offset === 0 ? rules : [''];
    	var size = sizeof(rule);

    	for (var i = 0, j = 0, k = 0; i < index; ++i)
    		for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)
    			if (z = trim(j > 0 ? rule[x] + ' ' + y : replace(y, /&\f/g, rule[x])))
    				props[k++] = z;

    	return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length)
    }

    /**
     * @param {number} value
     * @param {object} root
     * @param {object?} parent
     * @return {object}
     */
    function comment (value, root, parent) {
    	return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0)
    }

    /**
     * @param {string} value
     * @param {object} root
     * @param {object?} parent
     * @param {number} length
     * @return {object}
     */
    function declaration (value, root, parent, length) {
    	return node(value, root, parent, DECLARATION, substr(value, 0, length), substr(value, length + 1, -1), length)
    }

    /**
     * @param {object[]} children
     * @param {function} callback
     * @return {string}
     */
    function serialize (children, callback) {
    	var output = '';
    	var length = sizeof(children);

    	for (var i = 0; i < length; i++)
    		output += callback(children[i], i, children, callback) || '';

    	return output
    }

    /**
     * @param {object} element
     * @param {number} index
     * @param {object[]} children
     * @param {function} callback
     * @return {string}
     */
    function stringify (element, index, children, callback) {
    	switch (element.type) {
    		case LAYER: if (element.children.length) break
    		case IMPORT: case DECLARATION: return element.return = element.return || element.value
    		case COMMENT: return ''
    		case KEYFRAMES: return element.return = element.value + '{' + serialize(element.children, callback) + '}'
    		case RULESET: element.value = element.props.join(',');
    	}

    	return strlen(children = serialize(element.children, callback)) ? element.return = element.value + '{' + children + '}' : ''
    }

    /**
     * @param {function[]} collection
     * @return {function}
     */
    function middleware (collection) {
    	var length = sizeof(collection);

    	return function (element, index, children, callback) {
    		var output = '';

    		for (var i = 0; i < length; i++)
    			output += collection[i](element, index, children, callback) || '';

    		return output
    	}
    }

    /**
     * @param {function} callback
     * @return {function}
     */
    function rulesheet (callback) {
    	return function (element) {
    		if (!element.root)
    			if (element = element.return)
    				callback(element);
    	}
    }

    var weakMemoize = function weakMemoize(func) {
      // $FlowFixMe flow doesn't include all non-primitive types as allowed for weakmaps
      var cache = new WeakMap();
      return function (arg) {
        if (cache.has(arg)) {
          // $FlowFixMe
          return cache.get(arg);
        }

        var ret = func(arg);
        cache.set(arg, ret);
        return ret;
      };
    };

    function memoize(fn) {
      var cache = Object.create(null);
      return function (arg) {
        if (cache[arg] === undefined) cache[arg] = fn(arg);
        return cache[arg];
      };
    }

    var identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {
      var previous = 0;
      var character = 0;

      while (true) {
        previous = character;
        character = peek(); // &\f

        if (previous === 38 && character === 12) {
          points[index] = 1;
        }

        if (token(character)) {
          break;
        }

        next();
      }

      return slice(begin, position);
    };

    var toRules = function toRules(parsed, points) {
      // pretend we've started with a comma
      var index = -1;
      var character = 44;

      do {
        switch (token(character)) {
          case 0:
            // &\f
            if (character === 38 && peek() === 12) {
              // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
              // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
              // and when it should just concatenate the outer and inner selectors
              // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
              points[index] = 1;
            }

            parsed[index] += identifierWithPointTracking(position - 1, points, index);
            break;

          case 2:
            parsed[index] += delimit(character);
            break;

          case 4:
            // comma
            if (character === 44) {
              // colon
              parsed[++index] = peek() === 58 ? '&\f' : '';
              points[index] = parsed[index].length;
              break;
            }

          // fallthrough

          default:
            parsed[index] += from(character);
        }
      } while (character = next());

      return parsed;
    };

    var getRules = function getRules(value, points) {
      return dealloc(toRules(alloc(value), points));
    }; // WeakSet would be more appropriate, but only WeakMap is supported in IE11


    var fixedElements = /* #__PURE__ */new WeakMap();
    var compat = function compat(element) {
      if (element.type !== 'rule' || !element.parent || // positive .length indicates that this rule contains pseudo
      // negative .length indicates that this rule has been already prefixed
      element.length < 1) {
        return;
      }

      var value = element.value,
          parent = element.parent;
      var isImplicitRule = element.column === parent.column && element.line === parent.line;

      while (parent.type !== 'rule') {
        parent = parent.parent;
        if (!parent) return;
      } // short-circuit for the simplest case


      if (element.props.length === 1 && value.charCodeAt(0) !== 58
      /* colon */
      && !fixedElements.get(parent)) {
        return;
      } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
      // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"


      if (isImplicitRule) {
        return;
      }

      fixedElements.set(element, true);
      var points = [];
      var rules = getRules(value, points);
      var parentRules = parent.props;

      for (var i = 0, k = 0; i < rules.length; i++) {
        for (var j = 0; j < parentRules.length; j++, k++) {
          element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
        }
      }
    };
    var removeLabel = function removeLabel(element) {
      if (element.type === 'decl') {
        var value = element.value;

        if ( // charcode for l
        value.charCodeAt(0) === 108 && // charcode for b
        value.charCodeAt(2) === 98) {
          // this ignores label
          element["return"] = '';
          element.value = '';
        }
      }
    };
    var ignoreFlag = 'emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason';

    var isIgnoringComment = function isIgnoringComment(element) {
      return element.type === 'comm' && element.children.indexOf(ignoreFlag) > -1;
    };

    var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm(cache) {
      return function (element, index, children) {
        if (element.type !== 'rule' || cache.compat) return;
        var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);

        if (unsafePseudoClasses) {
          var isNested = !!element.parent; // in nested rules comments become children of the "auto-inserted" rule and that's always the `element.parent`
          //
          // considering this input:
          // .a {
          //   .b /* comm */ {}
          //   color: hotpink;
          // }
          // we get output corresponding to this:
          // .a {
          //   & {
          //     /* comm */
          //     color: hotpink;
          //   }
          //   .b {}
          // }

          var commentContainer = isNested ? element.parent.children : // global rule at the root level
          children;

          for (var i = commentContainer.length - 1; i >= 0; i--) {
            var node = commentContainer[i];

            if (node.line < element.line) {
              break;
            } // it is quite weird but comments are *usually* put at `column: element.column - 1`
            // so we seek *from the end* for the node that is earlier than the rule's `element` and check that
            // this will also match inputs like this:
            // .a {
            //   /* comm */
            //   .b {}
            // }
            //
            // but that is fine
            //
            // it would be the easiest to change the placement of the comment to be the first child of the rule:
            // .a {
            //   .b { /* comm */ }
            // }
            // with such inputs we wouldn't have to search for the comment at all
            // TODO: consider changing this comment placement in the next major version


            if (node.column < element.column) {
              if (isIgnoringComment(node)) {
                return;
              }

              break;
            }
          }

          unsafePseudoClasses.forEach(function (unsafePseudoClass) {
            console.error("The pseudo class \"" + unsafePseudoClass + "\" is potentially unsafe when doing server-side rendering. Try changing it to \"" + unsafePseudoClass.split('-child')[0] + "-of-type\".");
          });
        }
      };
    };

    var isImportRule = function isImportRule(element) {
      return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
    };

    var isPrependedWithRegularRules = function isPrependedWithRegularRules(index, children) {
      for (var i = index - 1; i >= 0; i--) {
        if (!isImportRule(children[i])) {
          return true;
        }
      }

      return false;
    }; // use this to remove incorrect elements from further processing
    // so they don't get handed to the `sheet` (or anything else)
    // as that could potentially lead to additional logs which in turn could be overhelming to the user


    var nullifyElement = function nullifyElement(element) {
      element.type = '';
      element.value = '';
      element["return"] = '';
      element.children = '';
      element.props = '';
    };

    var incorrectImportAlarm = function incorrectImportAlarm(element, index, children) {
      if (!isImportRule(element)) {
        return;
      }

      if (element.parent) {
        console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
        nullifyElement(element);
      } else if (isPrependedWithRegularRules(index, children)) {
        console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
        nullifyElement(element);
      }
    };

    /* eslint-disable no-fallthrough */

    function prefix(value, length) {
      switch (hash(value, length)) {
        // color-adjust
        case 5103:
          return WEBKIT + 'print-' + value + value;
        // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)

        case 5737:
        case 4201:
        case 3177:
        case 3433:
        case 1641:
        case 4457:
        case 2921: // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break

        case 5572:
        case 6356:
        case 5844:
        case 3191:
        case 6645:
        case 3005: // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,

        case 6391:
        case 5879:
        case 5623:
        case 6135:
        case 4599:
        case 4855: // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)

        case 4215:
        case 6389:
        case 5109:
        case 5365:
        case 5621:
        case 3829:
          return WEBKIT + value + value;
        // appearance, user-select, transform, hyphens, text-size-adjust

        case 5349:
        case 4246:
        case 4810:
        case 6968:
        case 2756:
          return WEBKIT + value + MOZ + value + MS + value + value;
        // flex, flex-direction

        case 6828:
        case 4268:
          return WEBKIT + value + MS + value + value;
        // order

        case 6165:
          return WEBKIT + value + MS + 'flex-' + value + value;
        // align-items

        case 5187:
          return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + 'box-$1$2' + MS + 'flex-$1$2') + value;
        // align-self

        case 5443:
          return WEBKIT + value + MS + 'flex-item-' + replace(value, /flex-|-self/, '') + value;
        // align-content

        case 4675:
          return WEBKIT + value + MS + 'flex-line-pack' + replace(value, /align-content|flex-|-self/, '') + value;
        // flex-shrink

        case 5548:
          return WEBKIT + value + MS + replace(value, 'shrink', 'negative') + value;
        // flex-basis

        case 5292:
          return WEBKIT + value + MS + replace(value, 'basis', 'preferred-size') + value;
        // flex-grow

        case 6060:
          return WEBKIT + 'box-' + replace(value, '-grow', '') + WEBKIT + value + MS + replace(value, 'grow', 'positive') + value;
        // transition

        case 4554:
          return WEBKIT + replace(value, /([^-])(transform)/g, '$1' + WEBKIT + '$2') + value;
        // cursor

        case 6187:
          return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + '$1'), /(image-set)/, WEBKIT + '$1'), value, '') + value;
        // background, background-image

        case 5495:
        case 3959:
          return replace(value, /(image-set\([^]*)/, WEBKIT + '$1' + '$`$1');
        // justify-content

        case 4968:
          return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + 'box-pack:$3' + MS + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + WEBKIT + value + value;
        // (margin|padding)-inline-(start|end)

        case 4095:
        case 3583:
        case 4068:
        case 2532:
          return replace(value, /(.+)-inline(.+)/, WEBKIT + '$1$2') + value;
        // (min|max)?(width|height|inline-size|block-size)

        case 8116:
        case 7059:
        case 5753:
        case 5535:
        case 5445:
        case 5701:
        case 4933:
        case 4677:
        case 5533:
        case 5789:
        case 5021:
        case 4765:
          // stretch, max-content, min-content, fill-available
          if (strlen(value) - 1 - length > 6) switch (charat(value, length + 1)) {
            // (m)ax-content, (m)in-content
            case 109:
              // -
              if (charat(value, length + 4) !== 45) break;
            // (f)ill-available, (f)it-content

            case 102:
              return replace(value, /(.+:)(.+)-([^]+)/, '$1' + WEBKIT + '$2-$3' + '$1' + MOZ + (charat(value, length + 3) == 108 ? '$3' : '$2-$3')) + value;
            // (s)tretch

            case 115:
              return ~indexof(value, 'stretch') ? prefix(replace(value, 'stretch', 'fill-available'), length) + value : value;
          }
          break;
        // position: sticky

        case 4949:
          // (s)ticky?
          if (charat(value, length + 1) !== 115) break;
        // display: (flex|inline-flex)

        case 6444:
          switch (charat(value, strlen(value) - 3 - (~indexof(value, '!important') && 10))) {
            // stic(k)y
            case 107:
              return replace(value, ':', ':' + WEBKIT) + value;
            // (inline-)?fl(e)x

            case 101:
              return replace(value, /(.+:)([^;!]+)(;|!.+)?/, '$1' + WEBKIT + (charat(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + WEBKIT + '$2$3' + '$1' + MS + '$2box$3') + value;
          }

          break;
        // writing-mode

        case 5936:
          switch (charat(value, length + 11)) {
            // vertical-l(r)
            case 114:
              return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb') + value;
            // vertical-r(l)

            case 108:
              return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb-rl') + value;
            // horizontal(-)tb

            case 45:
              return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'lr') + value;
          }

          return WEBKIT + value + MS + value + value;
      }

      return value;
    }

    var prefixer = function prefixer(element, index, children, callback) {
      if (element.length > -1) if (!element["return"]) switch (element.type) {
        case DECLARATION:
          element["return"] = prefix(element.value, element.length);
          break;

        case KEYFRAMES:
          return serialize([copy(element, {
            value: replace(element.value, '@', '@' + WEBKIT)
          })], callback);

        case RULESET:
          if (element.length) return combine(element.props, function (value) {
            switch (match(value, /(::plac\w+|:read-\w+)/)) {
              // :read-(only|write)
              case ':read-only':
              case ':read-write':
                return serialize([copy(element, {
                  props: [replace(value, /:(read-\w+)/, ':' + MOZ + '$1')]
                })], callback);
              // :placeholder

              case '::placeholder':
                return serialize([copy(element, {
                  props: [replace(value, /:(plac\w+)/, ':' + WEBKIT + 'input-$1')]
                }), copy(element, {
                  props: [replace(value, /:(plac\w+)/, ':' + MOZ + '$1')]
                }), copy(element, {
                  props: [replace(value, /:(plac\w+)/, MS + 'input-$1')]
                })], callback);
            }

            return '';
          });
      }
    };

    var isBrowser$1 = typeof document !== 'undefined';
    var getServerStylisCache = isBrowser$1 ? undefined : weakMemoize(function () {
      return memoize(function () {
        var cache = {};
        return function (name) {
          return cache[name];
        };
      });
    });
    var defaultStylisPlugins = [prefixer];

    var createCache = function createCache(options) {
      var key = options.key;

      if (process.env.NODE_ENV !== 'production' && !key) {
        throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\n" + "If multiple caches share the same key they might \"fight\" for each other's style elements.");
      }

      if (isBrowser$1 && key === 'css') {
        var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])"); // get SSRed styles out of the way of React's hydration
        // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)
        // note this very very intentionally targets all style elements regardless of the key to ensure
        // that creating a cache works inside of render of a React component

        Array.prototype.forEach.call(ssrStyles, function (node) {
          // we want to only move elements which have a space in the data-emotion attribute value
          // because that indicates that it is an Emotion 11 server-side rendered style elements
          // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector
          // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)
          // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles
          // will not result in the Emotion 10 styles being destroyed
          var dataEmotionAttribute = node.getAttribute('data-emotion');

          if (dataEmotionAttribute.indexOf(' ') === -1) {
            return;
          }
          document.head.appendChild(node);
          node.setAttribute('data-s', '');
        });
      }

      var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;

      if (process.env.NODE_ENV !== 'production') {
        // $FlowFixMe
        if (/[^a-z-]/.test(key)) {
          throw new Error("Emotion key must only contain lower case alphabetical characters and - but \"" + key + "\" was passed");
        }
      }

      var inserted = {};
      var container;
      var nodesToHydrate = [];

      if (isBrowser$1) {
        container = options.container || document.head;
        Array.prototype.forEach.call( // this means we will ignore elements which don't have a space in them which
        // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
        document.querySelectorAll("style[data-emotion^=\"" + key + " \"]"), function (node) {
          var attrib = node.getAttribute("data-emotion").split(' '); // $FlowFixMe

          for (var i = 1; i < attrib.length; i++) {
            inserted[attrib[i]] = true;
          }

          nodesToHydrate.push(node);
        });
      }

      var _insert;

      var omnipresentPlugins = [compat, removeLabel];

      if (process.env.NODE_ENV !== 'production') {
        omnipresentPlugins.push(createUnsafeSelectorsAlarm({
          get compat() {
            return cache.compat;
          }

        }), incorrectImportAlarm);
      }

      if (isBrowser$1) {
        var currentSheet;
        var finalizingPlugins = [stringify, process.env.NODE_ENV !== 'production' ? function (element) {
          if (!element.root) {
            if (element["return"]) {
              currentSheet.insert(element["return"]);
            } else if (element.value && element.type !== COMMENT) {
              // insert empty rule in non-production environments
              // so @emotion/jest can grab `key` from the (JS)DOM for caches without any rules inserted yet
              currentSheet.insert(element.value + "{}");
            }
          }
        } : rulesheet(function (rule) {
          currentSheet.insert(rule);
        })];
        var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));

        var stylis = function stylis(styles) {
          return serialize(compile(styles), serializer);
        };

        _insert = function insert(selector, serialized, sheet, shouldCache) {
          currentSheet = sheet;

          if (process.env.NODE_ENV !== 'production' && serialized.map !== undefined) {
            currentSheet = {
              insert: function insert(rule) {
                sheet.insert(rule + serialized.map);
              }
            };
          }

          stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);

          if (shouldCache) {
            cache.inserted[serialized.name] = true;
          }
        };
      } else {
        var _finalizingPlugins = [stringify];

        var _serializer = middleware(omnipresentPlugins.concat(stylisPlugins, _finalizingPlugins));

        var _stylis = function _stylis(styles) {
          return serialize(compile(styles), _serializer);
        }; // $FlowFixMe


        var serverStylisCache = getServerStylisCache(stylisPlugins)(key);

        var getRules = function getRules(selector, serialized) {
          var name = serialized.name;

          if (serverStylisCache[name] === undefined) {
            serverStylisCache[name] = _stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
          }

          return serverStylisCache[name];
        };

        _insert = function _insert(selector, serialized, sheet, shouldCache) {
          var name = serialized.name;
          var rules = getRules(selector, serialized);

          if (cache.compat === undefined) {
            // in regular mode, we don't set the styles on the inserted cache
            // since we don't need to and that would be wasting memory
            // we return them so that they are rendered in a style tag
            if (shouldCache) {
              cache.inserted[name] = true;
            }

            if ( // using === development instead of !== production
            // because if people do ssr in tests, the source maps showing up would be annoying
            process.env.NODE_ENV === 'development' && serialized.map !== undefined) {
              return rules + serialized.map;
            }

            return rules;
          } else {
            // in compat mode, we put the styles on the inserted cache so
            // that emotion-server can pull out the styles
            // except when we don't want to cache it which was in Global but now
            // is nowhere but we don't want to do a major right now
            // and just in case we're going to leave the case here
            // it's also not affecting client side bundle size
            // so it's really not a big deal
            if (shouldCache) {
              cache.inserted[name] = rules;
            } else {
              return rules;
            }
          }
        };
      }

      var cache = {
        key: key,
        sheet: new StyleSheet({
          key: key,
          container: container,
          nonce: options.nonce,
          speedy: options.speedy,
          prepend: options.prepend,
          insertionPoint: options.insertionPoint
        }),
        nonce: options.nonce,
        inserted: inserted,
        registered: {},
        insert: _insert
      };
      cache.sheet.hydrate(nodesToHydrate);
      return cache;
    };

    /* eslint-disable */
    // Inspired by https://github.com/garycourt/murmurhash-js
    // Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
    function murmur2(str) {
      // 'm' and 'r' are mixing constants generated offline.
      // They're not really 'magic', they just happen to work well.
      // const m = 0x5bd1e995;
      // const r = 24;
      // Initialize the hash
      var h = 0; // Mix 4 bytes at a time into the hash

      var k,
          i = 0,
          len = str.length;

      for (; len >= 4; ++i, len -= 4) {
        k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
        k =
        /* Math.imul(k, m): */
        (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
        k ^=
        /* k >>> r: */
        k >>> 24;
        h =
        /* Math.imul(k, m): */
        (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^
        /* Math.imul(h, m): */
        (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
      } // Handle the last few bytes of the input array


      switch (len) {
        case 3:
          h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

        case 2:
          h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

        case 1:
          h ^= str.charCodeAt(i) & 0xff;
          h =
          /* Math.imul(h, m): */
          (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
      } // Do a few final mixes of the hash to ensure the last few
      // bytes are well-incorporated.


      h ^= h >>> 13;
      h =
      /* Math.imul(h, m): */
      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
      return ((h ^ h >>> 15) >>> 0).toString(36);
    }

    var unitlessKeys = {
      animationIterationCount: 1,
      aspectRatio: 1,
      borderImageOutset: 1,
      borderImageSlice: 1,
      borderImageWidth: 1,
      boxFlex: 1,
      boxFlexGroup: 1,
      boxOrdinalGroup: 1,
      columnCount: 1,
      columns: 1,
      flex: 1,
      flexGrow: 1,
      flexPositive: 1,
      flexShrink: 1,
      flexNegative: 1,
      flexOrder: 1,
      gridRow: 1,
      gridRowEnd: 1,
      gridRowSpan: 1,
      gridRowStart: 1,
      gridColumn: 1,
      gridColumnEnd: 1,
      gridColumnSpan: 1,
      gridColumnStart: 1,
      msGridRow: 1,
      msGridRowSpan: 1,
      msGridColumn: 1,
      msGridColumnSpan: 1,
      fontWeight: 1,
      lineHeight: 1,
      opacity: 1,
      order: 1,
      orphans: 1,
      tabSize: 1,
      widows: 1,
      zIndex: 1,
      zoom: 1,
      WebkitLineClamp: 1,
      // SVG-related properties
      fillOpacity: 1,
      floodOpacity: 1,
      stopOpacity: 1,
      strokeDasharray: 1,
      strokeDashoffset: 1,
      strokeMiterlimit: 1,
      strokeOpacity: 1,
      strokeWidth: 1
    };

    var ILLEGAL_ESCAPE_SEQUENCE_ERROR = "You have illegal escape sequence in your template literal, most likely inside content's property value.\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \"content: '\\00d7';\" should become \"content: '\\\\00d7';\".\nYou can read more about this here:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences";
    var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
    var hyphenateRegex = /[A-Z]|^ms/g;
    var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;

    var isCustomProperty = function isCustomProperty(property) {
      return property.charCodeAt(1) === 45;
    };

    var isProcessableValue = function isProcessableValue(value) {
      return value != null && typeof value !== 'boolean';
    };

    var processStyleName = /* #__PURE__ */memoize(function (styleName) {
      return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, '-$&').toLowerCase();
    });

    var processStyleValue = function processStyleValue(key, value) {
      switch (key) {
        case 'animation':
        case 'animationName':
          {
            if (typeof value === 'string') {
              return value.replace(animationRegex, function (match, p1, p2) {
                cursor = {
                  name: p1,
                  styles: p2,
                  next: cursor
                };
                return p1;
              });
            }
          }
      }

      if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === 'number' && value !== 0) {
        return value + 'px';
      }

      return value;
    };

    if (process.env.NODE_ENV !== 'production') {
      var contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
      var contentValues = ['normal', 'none', 'initial', 'inherit', 'unset'];
      var oldProcessStyleValue = processStyleValue;
      var msPattern = /^-ms-/;
      var hyphenPattern = /-(.)/g;
      var hyphenatedCache = {};

      processStyleValue = function processStyleValue(key, value) {
        if (key === 'content') {
          if (typeof value !== 'string' || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
            throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
          }
        }

        var processed = oldProcessStyleValue(key, value);

        if (processed !== '' && !isCustomProperty(key) && key.indexOf('-') !== -1 && hyphenatedCache[key] === undefined) {
          hyphenatedCache[key] = true;
          console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, 'ms-').replace(hyphenPattern, function (str, _char) {
            return _char.toUpperCase();
          }) + "?");
        }

        return processed;
      };
    }

    var noComponentSelectorMessage = 'Component selectors can only be used in conjunction with ' + '@emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware ' + 'compiler transform.';

    function handleInterpolation(mergedProps, registered, interpolation) {
      if (interpolation == null) {
        return '';
      }

      if (interpolation.__emotion_styles !== undefined) {
        if (process.env.NODE_ENV !== 'production' && interpolation.toString() === 'NO_COMPONENT_SELECTOR') {
          throw new Error(noComponentSelectorMessage);
        }

        return interpolation;
      }

      switch (typeof interpolation) {
        case 'boolean':
          {
            return '';
          }

        case 'object':
          {
            if (interpolation.anim === 1) {
              cursor = {
                name: interpolation.name,
                styles: interpolation.styles,
                next: cursor
              };
              return interpolation.name;
            }

            if (interpolation.styles !== undefined) {
              var next = interpolation.next;

              if (next !== undefined) {
                // not the most efficient thing ever but this is a pretty rare case
                // and there will be very few iterations of this generally
                while (next !== undefined) {
                  cursor = {
                    name: next.name,
                    styles: next.styles,
                    next: cursor
                  };
                  next = next.next;
                }
              }

              var styles = interpolation.styles + ";";

              if (process.env.NODE_ENV !== 'production' && interpolation.map !== undefined) {
                styles += interpolation.map;
              }

              return styles;
            }

            return createStringFromObject(mergedProps, registered, interpolation);
          }

        case 'function':
          {
            if (mergedProps !== undefined) {
              var previousCursor = cursor;
              var result = interpolation(mergedProps);
              cursor = previousCursor;
              return handleInterpolation(mergedProps, registered, result);
            } else if (process.env.NODE_ENV !== 'production') {
              console.error('Functions that are interpolated in css calls will be stringified.\n' + 'If you want to have a css call based on props, create a function that returns a css call like this\n' + 'let dynamicStyle = (props) => css`color: ${props.color}`\n' + 'It can be called directly with props or interpolated in a styled call like this\n' + "let SomeComponent = styled('div')`${dynamicStyle}`");
            }

            break;
          }

        case 'string':
          if (process.env.NODE_ENV !== 'production') {
            var matched = [];
            var replaced = interpolation.replace(animationRegex, function (match, p1, p2) {
              var fakeVarName = "animation" + matched.length;
              matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, '') + "`");
              return "${" + fakeVarName + "}";
            });

            if (matched.length) {
              console.error('`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\n' + 'Instead of doing this:\n\n' + [].concat(matched, ["`" + replaced + "`"]).join('\n') + '\n\nYou should wrap it with `css` like this:\n\n' + ("css`" + replaced + "`"));
            }
          }

          break;
      } // finalize string values (regular strings and functions interpolated into css calls)


      if (registered == null) {
        return interpolation;
      }

      var cached = registered[interpolation];
      return cached !== undefined ? cached : interpolation;
    }

    function createStringFromObject(mergedProps, registered, obj) {
      var string = '';

      if (Array.isArray(obj)) {
        for (var i = 0; i < obj.length; i++) {
          string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
        }
      } else {
        for (var _key in obj) {
          var value = obj[_key];

          if (typeof value !== 'object') {
            if (registered != null && registered[value] !== undefined) {
              string += _key + "{" + registered[value] + "}";
            } else if (isProcessableValue(value)) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
            }
          } else {
            if (_key === 'NO_COMPONENT_SELECTOR' && process.env.NODE_ENV !== 'production') {
              throw new Error(noComponentSelectorMessage);
            }

            if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {
              for (var _i = 0; _i < value.length; _i++) {
                if (isProcessableValue(value[_i])) {
                  string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
                }
              }
            } else {
              var interpolated = handleInterpolation(mergedProps, registered, value);

              switch (_key) {
                case 'animation':
                case 'animationName':
                  {
                    string += processStyleName(_key) + ":" + interpolated + ";";
                    break;
                  }

                default:
                  {
                    if (process.env.NODE_ENV !== 'production' && _key === 'undefined') {
                      console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
                    }

                    string += _key + "{" + interpolated + "}";
                  }
              }
            }
          }
        }
      }

      return string;
    }

    var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
    var sourceMapPattern;

    if (process.env.NODE_ENV !== 'production') {
      sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
    } // this is the cursor for keyframes
    // keyframes are stored on the SerializedStyles object as a linked list


    var cursor;
    var serializeStyles = function serializeStyles(args, registered, mergedProps) {
      if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null && args[0].styles !== undefined) {
        return args[0];
      }

      var stringMode = true;
      var styles = '';
      cursor = undefined;
      var strings = args[0];

      if (strings == null || strings.raw === undefined) {
        stringMode = false;
        styles += handleInterpolation(mergedProps, registered, strings);
      } else {
        if (process.env.NODE_ENV !== 'production' && strings[0] === undefined) {
          console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
        }

        styles += strings[0];
      } // we start at 1 since we've already handled the first arg


      for (var i = 1; i < args.length; i++) {
        styles += handleInterpolation(mergedProps, registered, args[i]);

        if (stringMode) {
          if (process.env.NODE_ENV !== 'production' && strings[i] === undefined) {
            console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
          }

          styles += strings[i];
        }
      }

      var sourceMap;

      if (process.env.NODE_ENV !== 'production') {
        styles = styles.replace(sourceMapPattern, function (match) {
          sourceMap = match;
          return '';
        });
      } // using a global regex with .exec is stateful so lastIndex has to be reset each time


      labelPattern.lastIndex = 0;
      var identifierName = '';
      var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5

      while ((match = labelPattern.exec(styles)) !== null) {
        identifierName += '-' + // $FlowFixMe we know it's not null
        match[1];
      }

      var name = murmur2(styles) + identifierName;

      if (process.env.NODE_ENV !== 'production') {
        // $FlowFixMe SerializedStyles type doesn't have toString property (and we don't want to add it)
        return {
          name: name,
          styles: styles,
          map: sourceMap,
          next: cursor,
          toString: function toString() {
            return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
          }
        };
      }

      return {
        name: name,
        styles: styles,
        next: cursor
      };
    };

    var isBrowser = typeof document !== 'undefined';
    function getRegisteredStyles(registered, registeredStyles, classNames) {
      var rawClassName = '';
      classNames.split(' ').forEach(function (className) {
        if (registered[className] !== undefined) {
          registeredStyles.push(registered[className] + ";");
        } else {
          rawClassName += className + " ";
        }
      });
      return rawClassName;
    }
    var registerStyles = function registerStyles(cache, serialized, isStringTag) {
      var className = cache.key + "-" + serialized.name;

      if ( // we only need to add the styles to the registered cache if the
      // class name could be used further down
      // the tree but if it's a string tag, we know it won't
      // so we don't have to add it to registered cache.
      // this improves memory usage since we can avoid storing the whole style string
      (isStringTag === false || // we need to always store it if we're in compat mode and
      // in node since emotion-server relies on whether a style is in
      // the registered cache to know whether a style is global or not
      // also, note that this check will be dead code eliminated in the browser
      isBrowser === false && cache.compat !== undefined) && cache.registered[className] === undefined) {
        cache.registered[className] = serialized.styles;
      }
    };
    var insertStyles = function insertStyles(cache, serialized, isStringTag) {
      registerStyles(cache, serialized, isStringTag);
      var className = cache.key + "-" + serialized.name;

      if (cache.inserted[serialized.name] === undefined) {
        var stylesForSSR = '';
        var current = serialized;

        do {
          var maybeStyles = cache.insert(serialized === current ? "." + className : '', current, cache.sheet, true);

          if (!isBrowser && maybeStyles !== undefined) {
            stylesForSSR += maybeStyles;
          }

          current = current.next;
        } while (current !== undefined);

        if (!isBrowser && stylesForSSR.length !== 0) {
          return stylesForSSR;
        }
      }
    };

    function insertWithoutScoping(cache, serialized) {
      if (cache.inserted[serialized.name] === undefined) {
        return cache.insert('', serialized, cache.sheet, true);
      }
    }

    function merge(registered, css, className) {
      var registeredStyles = [];
      var rawClassName = getRegisteredStyles(registered, registeredStyles, className);

      if (registeredStyles.length < 2) {
        return className;
      }

      return rawClassName + css(registeredStyles);
    }

    var createEmotion = function createEmotion(options) {
      var cache = createCache(options); // $FlowFixMe

      cache.sheet.speedy = function (value) {
        if (process.env.NODE_ENV !== 'production' && this.ctr !== 0) {
          throw new Error('speedy must be changed before any rules are inserted');
        }

        this.isSpeedy = value;
      };

      cache.compat = true;

      var css = function css() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var serialized = serializeStyles(args, cache.registered, undefined);
        insertStyles(cache, serialized, false);
        return cache.key + "-" + serialized.name;
      };

      var keyframes = function keyframes() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        var serialized = serializeStyles(args, cache.registered);
        var animation = "animation-" + serialized.name;
        insertWithoutScoping(cache, {
          name: serialized.name,
          styles: "@keyframes " + animation + "{" + serialized.styles + "}"
        });
        return animation;
      };

      var injectGlobal = function injectGlobal() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        var serialized = serializeStyles(args, cache.registered);
        insertWithoutScoping(cache, serialized);
      };

      var cx = function cx() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        return merge(cache.registered, css, classnames(args));
      };

      return {
        css: css,
        cx: cx,
        injectGlobal: injectGlobal,
        keyframes: keyframes,
        hydrate: function hydrate(ids) {
          ids.forEach(function (key) {
            cache.inserted[key] = true;
          });
        },
        flush: function flush() {
          cache.registered = {};
          cache.inserted = {};
          cache.sheet.flush();
        },
        // $FlowFixMe
        sheet: cache.sheet,
        cache: cache,
        getRegisteredStyles: getRegisteredStyles.bind(null, cache.registered),
        merge: merge.bind(null, cache.registered, css)
      };
    };

    var classnames = function classnames(args) {
      var cls = '';

      for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        if (arg == null) continue;
        var toAdd = void 0;

        switch (typeof arg) {
          case 'boolean':
            break;

          case 'object':
            {
              if (Array.isArray(arg)) {
                toAdd = classnames(arg);
              } else {
                toAdd = '';

                for (var k in arg) {
                  if (arg[k] && k) {
                    toAdd && (toAdd += ' ');
                    toAdd += k;
                  }
                }
              }

              break;
            }

          default:
            {
              toAdd = arg;
            }
        }

        if (toAdd) {
          cls && (cls += ' ');
          cls += toAdd;
        }
      }

      return cls;
    };

    var _createEmotion = createEmotion({
      key: 'css'
    }),
        css = _createEmotion.css;

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    var propTypes = {exports: {}};

    var reactIs = {exports: {}};

    var reactIs_production_min = {};

    /** @license React v16.13.1
     * react-is.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredReactIs_production_min;

    function requireReactIs_production_min () {
    	if (hasRequiredReactIs_production_min) return reactIs_production_min;
    	hasRequiredReactIs_production_min = 1;
    var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
    	Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
    	function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}reactIs_production_min.AsyncMode=l;reactIs_production_min.ConcurrentMode=m;reactIs_production_min.ContextConsumer=k;reactIs_production_min.ContextProvider=h;reactIs_production_min.Element=c;reactIs_production_min.ForwardRef=n;reactIs_production_min.Fragment=e;reactIs_production_min.Lazy=t;reactIs_production_min.Memo=r;reactIs_production_min.Portal=d;
    	reactIs_production_min.Profiler=g;reactIs_production_min.StrictMode=f;reactIs_production_min.Suspense=p;reactIs_production_min.isAsyncMode=function(a){return A(a)||z(a)===l};reactIs_production_min.isConcurrentMode=A;reactIs_production_min.isContextConsumer=function(a){return z(a)===k};reactIs_production_min.isContextProvider=function(a){return z(a)===h};reactIs_production_min.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};reactIs_production_min.isForwardRef=function(a){return z(a)===n};reactIs_production_min.isFragment=function(a){return z(a)===e};reactIs_production_min.isLazy=function(a){return z(a)===t};
    	reactIs_production_min.isMemo=function(a){return z(a)===r};reactIs_production_min.isPortal=function(a){return z(a)===d};reactIs_production_min.isProfiler=function(a){return z(a)===g};reactIs_production_min.isStrictMode=function(a){return z(a)===f};reactIs_production_min.isSuspense=function(a){return z(a)===p};
    	reactIs_production_min.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};reactIs_production_min.typeOf=z;
    	return reactIs_production_min;
    }

    var reactIs_development = {};

    /** @license React v16.13.1
     * react-is.development.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredReactIs_development;

    function requireReactIs_development () {
    	if (hasRequiredReactIs_development) return reactIs_development;
    	hasRequiredReactIs_development = 1;



    	if (process.env.NODE_ENV !== "production") {
    	  (function() {

    	// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    	// nor polyfill, then a plain number is used for performance.
    	var hasSymbol = typeof Symbol === 'function' && Symbol.for;
    	var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
    	var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
    	var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
    	var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
    	var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
    	var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
    	var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
    	// (unstable) APIs that have been removed. Can we remove the symbols?

    	var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
    	var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
    	var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
    	var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
    	var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
    	var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
    	var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
    	var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
    	var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
    	var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
    	var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

    	function isValidElementType(type) {
    	  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
    	  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
    	}

    	function typeOf(object) {
    	  if (typeof object === 'object' && object !== null) {
    	    var $$typeof = object.$$typeof;

    	    switch ($$typeof) {
    	      case REACT_ELEMENT_TYPE:
    	        var type = object.type;

    	        switch (type) {
    	          case REACT_ASYNC_MODE_TYPE:
    	          case REACT_CONCURRENT_MODE_TYPE:
    	          case REACT_FRAGMENT_TYPE:
    	          case REACT_PROFILER_TYPE:
    	          case REACT_STRICT_MODE_TYPE:
    	          case REACT_SUSPENSE_TYPE:
    	            return type;

    	          default:
    	            var $$typeofType = type && type.$$typeof;

    	            switch ($$typeofType) {
    	              case REACT_CONTEXT_TYPE:
    	              case REACT_FORWARD_REF_TYPE:
    	              case REACT_LAZY_TYPE:
    	              case REACT_MEMO_TYPE:
    	              case REACT_PROVIDER_TYPE:
    	                return $$typeofType;

    	              default:
    	                return $$typeof;
    	            }

    	        }

    	      case REACT_PORTAL_TYPE:
    	        return $$typeof;
    	    }
    	  }

    	  return undefined;
    	} // AsyncMode is deprecated along with isAsyncMode

    	var AsyncMode = REACT_ASYNC_MODE_TYPE;
    	var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
    	var ContextConsumer = REACT_CONTEXT_TYPE;
    	var ContextProvider = REACT_PROVIDER_TYPE;
    	var Element = REACT_ELEMENT_TYPE;
    	var ForwardRef = REACT_FORWARD_REF_TYPE;
    	var Fragment = REACT_FRAGMENT_TYPE;
    	var Lazy = REACT_LAZY_TYPE;
    	var Memo = REACT_MEMO_TYPE;
    	var Portal = REACT_PORTAL_TYPE;
    	var Profiler = REACT_PROFILER_TYPE;
    	var StrictMode = REACT_STRICT_MODE_TYPE;
    	var Suspense = REACT_SUSPENSE_TYPE;
    	var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

    	function isAsyncMode(object) {
    	  {
    	    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
    	      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

    	      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    	    }
    	  }

    	  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
    	}
    	function isConcurrentMode(object) {
    	  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
    	}
    	function isContextConsumer(object) {
    	  return typeOf(object) === REACT_CONTEXT_TYPE;
    	}
    	function isContextProvider(object) {
    	  return typeOf(object) === REACT_PROVIDER_TYPE;
    	}
    	function isElement(object) {
    	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    	}
    	function isForwardRef(object) {
    	  return typeOf(object) === REACT_FORWARD_REF_TYPE;
    	}
    	function isFragment(object) {
    	  return typeOf(object) === REACT_FRAGMENT_TYPE;
    	}
    	function isLazy(object) {
    	  return typeOf(object) === REACT_LAZY_TYPE;
    	}
    	function isMemo(object) {
    	  return typeOf(object) === REACT_MEMO_TYPE;
    	}
    	function isPortal(object) {
    	  return typeOf(object) === REACT_PORTAL_TYPE;
    	}
    	function isProfiler(object) {
    	  return typeOf(object) === REACT_PROFILER_TYPE;
    	}
    	function isStrictMode(object) {
    	  return typeOf(object) === REACT_STRICT_MODE_TYPE;
    	}
    	function isSuspense(object) {
    	  return typeOf(object) === REACT_SUSPENSE_TYPE;
    	}

    	reactIs_development.AsyncMode = AsyncMode;
    	reactIs_development.ConcurrentMode = ConcurrentMode;
    	reactIs_development.ContextConsumer = ContextConsumer;
    	reactIs_development.ContextProvider = ContextProvider;
    	reactIs_development.Element = Element;
    	reactIs_development.ForwardRef = ForwardRef;
    	reactIs_development.Fragment = Fragment;
    	reactIs_development.Lazy = Lazy;
    	reactIs_development.Memo = Memo;
    	reactIs_development.Portal = Portal;
    	reactIs_development.Profiler = Profiler;
    	reactIs_development.StrictMode = StrictMode;
    	reactIs_development.Suspense = Suspense;
    	reactIs_development.isAsyncMode = isAsyncMode;
    	reactIs_development.isConcurrentMode = isConcurrentMode;
    	reactIs_development.isContextConsumer = isContextConsumer;
    	reactIs_development.isContextProvider = isContextProvider;
    	reactIs_development.isElement = isElement;
    	reactIs_development.isForwardRef = isForwardRef;
    	reactIs_development.isFragment = isFragment;
    	reactIs_development.isLazy = isLazy;
    	reactIs_development.isMemo = isMemo;
    	reactIs_development.isPortal = isPortal;
    	reactIs_development.isProfiler = isProfiler;
    	reactIs_development.isStrictMode = isStrictMode;
    	reactIs_development.isSuspense = isSuspense;
    	reactIs_development.isValidElementType = isValidElementType;
    	reactIs_development.typeOf = typeOf;
    	  })();
    	}
    	return reactIs_development;
    }

    var hasRequiredReactIs;

    function requireReactIs () {
    	if (hasRequiredReactIs) return reactIs.exports;
    	hasRequiredReactIs = 1;

    	if (process.env.NODE_ENV === 'production') {
    	  reactIs.exports = requireReactIs_production_min();
    	} else {
    	  reactIs.exports = requireReactIs_development();
    	}
    	return reactIs.exports;
    }

    /*
    object-assign
    (c) Sindre Sorhus
    @license MIT
    */

    var objectAssign;
    var hasRequiredObjectAssign;

    function requireObjectAssign () {
    	if (hasRequiredObjectAssign) return objectAssign;
    	hasRequiredObjectAssign = 1;
    	/* eslint-disable no-unused-vars */
    	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    	var hasOwnProperty = Object.prototype.hasOwnProperty;
    	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

    	function toObject(val) {
    		if (val === null || val === undefined) {
    			throw new TypeError('Object.assign cannot be called with null or undefined');
    		}

    		return Object(val);
    	}

    	function shouldUseNative() {
    		try {
    			if (!Object.assign) {
    				return false;
    			}

    			// Detect buggy property enumeration order in older V8 versions.

    			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
    			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
    			test1[5] = 'de';
    			if (Object.getOwnPropertyNames(test1)[0] === '5') {
    				return false;
    			}

    			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
    			var test2 = {};
    			for (var i = 0; i < 10; i++) {
    				test2['_' + String.fromCharCode(i)] = i;
    			}
    			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
    				return test2[n];
    			});
    			if (order2.join('') !== '0123456789') {
    				return false;
    			}

    			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
    			var test3 = {};
    			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
    				test3[letter] = letter;
    			});
    			if (Object.keys(Object.assign({}, test3)).join('') !==
    					'abcdefghijklmnopqrst') {
    				return false;
    			}

    			return true;
    		} catch (err) {
    			// We don't expect any of the above to throw, but better to be safe.
    			return false;
    		}
    	}

    	objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
    		var from;
    		var to = toObject(target);
    		var symbols;

    		for (var s = 1; s < arguments.length; s++) {
    			from = Object(arguments[s]);

    			for (var key in from) {
    				if (hasOwnProperty.call(from, key)) {
    					to[key] = from[key];
    				}
    			}

    			if (getOwnPropertySymbols) {
    				symbols = getOwnPropertySymbols(from);
    				for (var i = 0; i < symbols.length; i++) {
    					if (propIsEnumerable.call(from, symbols[i])) {
    						to[symbols[i]] = from[symbols[i]];
    					}
    				}
    			}
    		}

    		return to;
    	};
    	return objectAssign;
    }

    /**
     * Copyright (c) 2013-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var ReactPropTypesSecret_1;
    var hasRequiredReactPropTypesSecret;

    function requireReactPropTypesSecret () {
    	if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
    	hasRequiredReactPropTypesSecret = 1;

    	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

    	ReactPropTypesSecret_1 = ReactPropTypesSecret;
    	return ReactPropTypesSecret_1;
    }

    var has;
    var hasRequiredHas;

    function requireHas () {
    	if (hasRequiredHas) return has;
    	hasRequiredHas = 1;
    	has = Function.call.bind(Object.prototype.hasOwnProperty);
    	return has;
    }

    /**
     * Copyright (c) 2013-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var checkPropTypes_1;
    var hasRequiredCheckPropTypes;

    function requireCheckPropTypes () {
    	if (hasRequiredCheckPropTypes) return checkPropTypes_1;
    	hasRequiredCheckPropTypes = 1;

    	var printWarning = function() {};

    	if (process.env.NODE_ENV !== 'production') {
    	  var ReactPropTypesSecret = requireReactPropTypesSecret();
    	  var loggedTypeFailures = {};
    	  var has = requireHas();

    	  printWarning = function(text) {
    	    var message = 'Warning: ' + text;
    	    if (typeof console !== 'undefined') {
    	      console.error(message);
    	    }
    	    try {
    	      // --- Welcome to debugging React ---
    	      // This error was thrown as a convenience so that you can use this stack
    	      // to find the callsite that caused this warning to fire.
    	      throw new Error(message);
    	    } catch (x) { /**/ }
    	  };
    	}

    	/**
    	 * Assert that the values match with the type specs.
    	 * Error messages are memorized and will only be shown once.
    	 *
    	 * @param {object} typeSpecs Map of name to a ReactPropType
    	 * @param {object} values Runtime values that need to be type-checked
    	 * @param {string} location e.g. "prop", "context", "child context"
    	 * @param {string} componentName Name of the component for error messages.
    	 * @param {?Function} getStack Returns the component stack.
    	 * @private
    	 */
    	function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
    	  if (process.env.NODE_ENV !== 'production') {
    	    for (var typeSpecName in typeSpecs) {
    	      if (has(typeSpecs, typeSpecName)) {
    	        var error;
    	        // Prop type validation may throw. In case they do, we don't want to
    	        // fail the render phase where it didn't fail before. So we log it.
    	        // After these have been cleaned up, we'll let them throw.
    	        try {
    	          // This is intentionally an invariant that gets caught. It's the same
    	          // behavior as without this statement except with a better message.
    	          if (typeof typeSpecs[typeSpecName] !== 'function') {
    	            var err = Error(
    	              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
    	              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +
    	              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
    	            );
    	            err.name = 'Invariant Violation';
    	            throw err;
    	          }
    	          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
    	        } catch (ex) {
    	          error = ex;
    	        }
    	        if (error && !(error instanceof Error)) {
    	          printWarning(
    	            (componentName || 'React class') + ': type specification of ' +
    	            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
    	            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
    	            'You may have forgotten to pass an argument to the type checker ' +
    	            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
    	            'shape all require an argument).'
    	          );
    	        }
    	        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
    	          // Only monitor this failure once because there tends to be a lot of the
    	          // same error.
    	          loggedTypeFailures[error.message] = true;

    	          var stack = getStack ? getStack() : '';

    	          printWarning(
    	            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
    	          );
    	        }
    	      }
    	    }
    	  }
    	}

    	/**
    	 * Resets warning cache when testing.
    	 *
    	 * @private
    	 */
    	checkPropTypes.resetWarningCache = function() {
    	  if (process.env.NODE_ENV !== 'production') {
    	    loggedTypeFailures = {};
    	  }
    	};

    	checkPropTypes_1 = checkPropTypes;
    	return checkPropTypes_1;
    }

    /**
     * Copyright (c) 2013-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var factoryWithTypeCheckers;
    var hasRequiredFactoryWithTypeCheckers;

    function requireFactoryWithTypeCheckers () {
    	if (hasRequiredFactoryWithTypeCheckers) return factoryWithTypeCheckers;
    	hasRequiredFactoryWithTypeCheckers = 1;

    	var ReactIs = requireReactIs();
    	var assign = requireObjectAssign();

    	var ReactPropTypesSecret = requireReactPropTypesSecret();
    	var has = requireHas();
    	var checkPropTypes = requireCheckPropTypes();

    	var printWarning = function() {};

    	if (process.env.NODE_ENV !== 'production') {
    	  printWarning = function(text) {
    	    var message = 'Warning: ' + text;
    	    if (typeof console !== 'undefined') {
    	      console.error(message);
    	    }
    	    try {
    	      // --- Welcome to debugging React ---
    	      // This error was thrown as a convenience so that you can use this stack
    	      // to find the callsite that caused this warning to fire.
    	      throw new Error(message);
    	    } catch (x) {}
    	  };
    	}

    	function emptyFunctionThatReturnsNull() {
    	  return null;
    	}

    	factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
    	  /* global Symbol */
    	  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    	  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

    	  /**
    	   * Returns the iterator method function contained on the iterable object.
    	   *
    	   * Be sure to invoke the function with the iterable as context:
    	   *
    	   *     var iteratorFn = getIteratorFn(myIterable);
    	   *     if (iteratorFn) {
    	   *       var iterator = iteratorFn.call(myIterable);
    	   *       ...
    	   *     }
    	   *
    	   * @param {?object} maybeIterable
    	   * @return {?function}
    	   */
    	  function getIteratorFn(maybeIterable) {
    	    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    	    if (typeof iteratorFn === 'function') {
    	      return iteratorFn;
    	    }
    	  }

    	  /**
    	   * Collection of methods that allow declaration and validation of props that are
    	   * supplied to React components. Example usage:
    	   *
    	   *   var Props = require('ReactPropTypes');
    	   *   var MyArticle = React.createClass({
    	   *     propTypes: {
    	   *       // An optional string prop named "description".
    	   *       description: Props.string,
    	   *
    	   *       // A required enum prop named "category".
    	   *       category: Props.oneOf(['News','Photos']).isRequired,
    	   *
    	   *       // A prop named "dialog" that requires an instance of Dialog.
    	   *       dialog: Props.instanceOf(Dialog).isRequired
    	   *     },
    	   *     render: function() { ... }
    	   *   });
    	   *
    	   * A more formal specification of how these methods are used:
    	   *
    	   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
    	   *   decl := ReactPropTypes.{type}(.isRequired)?
    	   *
    	   * Each and every declaration produces a function with the same signature. This
    	   * allows the creation of custom validation functions. For example:
    	   *
    	   *  var MyLink = React.createClass({
    	   *    propTypes: {
    	   *      // An optional string or URI prop named "href".
    	   *      href: function(props, propName, componentName) {
    	   *        var propValue = props[propName];
    	   *        if (propValue != null && typeof propValue !== 'string' &&
    	   *            !(propValue instanceof URI)) {
    	   *          return new Error(
    	   *            'Expected a string or an URI for ' + propName + ' in ' +
    	   *            componentName
    	   *          );
    	   *        }
    	   *      }
    	   *    },
    	   *    render: function() {...}
    	   *  });
    	   *
    	   * @internal
    	   */

    	  var ANONYMOUS = '<<anonymous>>';

    	  // Important!
    	  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
    	  var ReactPropTypes = {
    	    array: createPrimitiveTypeChecker('array'),
    	    bigint: createPrimitiveTypeChecker('bigint'),
    	    bool: createPrimitiveTypeChecker('boolean'),
    	    func: createPrimitiveTypeChecker('function'),
    	    number: createPrimitiveTypeChecker('number'),
    	    object: createPrimitiveTypeChecker('object'),
    	    string: createPrimitiveTypeChecker('string'),
    	    symbol: createPrimitiveTypeChecker('symbol'),

    	    any: createAnyTypeChecker(),
    	    arrayOf: createArrayOfTypeChecker,
    	    element: createElementTypeChecker(),
    	    elementType: createElementTypeTypeChecker(),
    	    instanceOf: createInstanceTypeChecker,
    	    node: createNodeChecker(),
    	    objectOf: createObjectOfTypeChecker,
    	    oneOf: createEnumTypeChecker,
    	    oneOfType: createUnionTypeChecker,
    	    shape: createShapeTypeChecker,
    	    exact: createStrictShapeTypeChecker,
    	  };

    	  /**
    	   * inlined Object.is polyfill to avoid requiring consumers ship their own
    	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
    	   */
    	  /*eslint-disable no-self-compare*/
    	  function is(x, y) {
    	    // SameValue algorithm
    	    if (x === y) {
    	      // Steps 1-5, 7-10
    	      // Steps 6.b-6.e: +0 != -0
    	      return x !== 0 || 1 / x === 1 / y;
    	    } else {
    	      // Step 6.a: NaN == NaN
    	      return x !== x && y !== y;
    	    }
    	  }
    	  /*eslint-enable no-self-compare*/

    	  /**
    	   * We use an Error-like object for backward compatibility as people may call
    	   * PropTypes directly and inspect their output. However, we don't use real
    	   * Errors anymore. We don't inspect their stack anyway, and creating them
    	   * is prohibitively expensive if they are created too often, such as what
    	   * happens in oneOfType() for any type before the one that matched.
    	   */
    	  function PropTypeError(message, data) {
    	    this.message = message;
    	    this.data = data && typeof data === 'object' ? data: {};
    	    this.stack = '';
    	  }
    	  // Make `instanceof Error` still work for returned errors.
    	  PropTypeError.prototype = Error.prototype;

    	  function createChainableTypeChecker(validate) {
    	    if (process.env.NODE_ENV !== 'production') {
    	      var manualPropTypeCallCache = {};
    	      var manualPropTypeWarningCount = 0;
    	    }
    	    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
    	      componentName = componentName || ANONYMOUS;
    	      propFullName = propFullName || propName;

    	      if (secret !== ReactPropTypesSecret) {
    	        if (throwOnDirectAccess) {
    	          // New behavior only for users of `prop-types` package
    	          var err = new Error(
    	            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
    	            'Use `PropTypes.checkPropTypes()` to call them. ' +
    	            'Read more at http://fb.me/use-check-prop-types'
    	          );
    	          err.name = 'Invariant Violation';
    	          throw err;
    	        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
    	          // Old behavior for people using React.PropTypes
    	          var cacheKey = componentName + ':' + propName;
    	          if (
    	            !manualPropTypeCallCache[cacheKey] &&
    	            // Avoid spamming the console because they are often not actionable except for lib authors
    	            manualPropTypeWarningCount < 3
    	          ) {
    	            printWarning(
    	              'You are manually calling a React.PropTypes validation ' +
    	              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +
    	              'and will throw in the standalone `prop-types` package. ' +
    	              'You may be seeing this warning due to a third-party PropTypes ' +
    	              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
    	            );
    	            manualPropTypeCallCache[cacheKey] = true;
    	            manualPropTypeWarningCount++;
    	          }
    	        }
    	      }
    	      if (props[propName] == null) {
    	        if (isRequired) {
    	          if (props[propName] === null) {
    	            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
    	          }
    	          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
    	        }
    	        return null;
    	      } else {
    	        return validate(props, propName, componentName, location, propFullName);
    	      }
    	    }

    	    var chainedCheckType = checkType.bind(null, false);
    	    chainedCheckType.isRequired = checkType.bind(null, true);

    	    return chainedCheckType;
    	  }

    	  function createPrimitiveTypeChecker(expectedType) {
    	    function validate(props, propName, componentName, location, propFullName, secret) {
    	      var propValue = props[propName];
    	      var propType = getPropType(propValue);
    	      if (propType !== expectedType) {
    	        // `propValue` being instance of, say, date/regexp, pass the 'object'
    	        // check, but we can offer a more precise error message here rather than
    	        // 'of type `object`'.
    	        var preciseType = getPreciseType(propValue);

    	        return new PropTypeError(
    	          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),
    	          {expectedType: expectedType}
    	        );
    	      }
    	      return null;
    	    }
    	    return createChainableTypeChecker(validate);
    	  }

    	  function createAnyTypeChecker() {
    	    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
    	  }

    	  function createArrayOfTypeChecker(typeChecker) {
    	    function validate(props, propName, componentName, location, propFullName) {
    	      if (typeof typeChecker !== 'function') {
    	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
    	      }
    	      var propValue = props[propName];
    	      if (!Array.isArray(propValue)) {
    	        var propType = getPropType(propValue);
    	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
    	      }
    	      for (var i = 0; i < propValue.length; i++) {
    	        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
    	        if (error instanceof Error) {
    	          return error;
    	        }
    	      }
    	      return null;
    	    }
    	    return createChainableTypeChecker(validate);
    	  }

    	  function createElementTypeChecker() {
    	    function validate(props, propName, componentName, location, propFullName) {
    	      var propValue = props[propName];
    	      if (!isValidElement(propValue)) {
    	        var propType = getPropType(propValue);
    	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
    	      }
    	      return null;
    	    }
    	    return createChainableTypeChecker(validate);
    	  }

    	  function createElementTypeTypeChecker() {
    	    function validate(props, propName, componentName, location, propFullName) {
    	      var propValue = props[propName];
    	      if (!ReactIs.isValidElementType(propValue)) {
    	        var propType = getPropType(propValue);
    	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
    	      }
    	      return null;
    	    }
    	    return createChainableTypeChecker(validate);
    	  }

    	  function createInstanceTypeChecker(expectedClass) {
    	    function validate(props, propName, componentName, location, propFullName) {
    	      if (!(props[propName] instanceof expectedClass)) {
    	        var expectedClassName = expectedClass.name || ANONYMOUS;
    	        var actualClassName = getClassName(props[propName]);
    	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
    	      }
    	      return null;
    	    }
    	    return createChainableTypeChecker(validate);
    	  }

    	  function createEnumTypeChecker(expectedValues) {
    	    if (!Array.isArray(expectedValues)) {
    	      if (process.env.NODE_ENV !== 'production') {
    	        if (arguments.length > 1) {
    	          printWarning(
    	            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
    	            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
    	          );
    	        } else {
    	          printWarning('Invalid argument supplied to oneOf, expected an array.');
    	        }
    	      }
    	      return emptyFunctionThatReturnsNull;
    	    }

    	    function validate(props, propName, componentName, location, propFullName) {
    	      var propValue = props[propName];
    	      for (var i = 0; i < expectedValues.length; i++) {
    	        if (is(propValue, expectedValues[i])) {
    	          return null;
    	        }
    	      }

    	      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
    	        var type = getPreciseType(value);
    	        if (type === 'symbol') {
    	          return String(value);
    	        }
    	        return value;
    	      });
    	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    	    }
    	    return createChainableTypeChecker(validate);
    	  }

    	  function createObjectOfTypeChecker(typeChecker) {
    	    function validate(props, propName, componentName, location, propFullName) {
    	      if (typeof typeChecker !== 'function') {
    	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
    	      }
    	      var propValue = props[propName];
    	      var propType = getPropType(propValue);
    	      if (propType !== 'object') {
    	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
    	      }
    	      for (var key in propValue) {
    	        if (has(propValue, key)) {
    	          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
    	          if (error instanceof Error) {
    	            return error;
    	          }
    	        }
    	      }
    	      return null;
    	    }
    	    return createChainableTypeChecker(validate);
    	  }

    	  function createUnionTypeChecker(arrayOfTypeCheckers) {
    	    if (!Array.isArray(arrayOfTypeCheckers)) {
    	      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
    	      return emptyFunctionThatReturnsNull;
    	    }

    	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
    	      var checker = arrayOfTypeCheckers[i];
    	      if (typeof checker !== 'function') {
    	        printWarning(
    	          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
    	          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
    	        );
    	        return emptyFunctionThatReturnsNull;
    	      }
    	    }

    	    function validate(props, propName, componentName, location, propFullName) {
    	      var expectedTypes = [];
    	      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
    	        var checker = arrayOfTypeCheckers[i];
    	        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
    	        if (checkerResult == null) {
    	          return null;
    	        }
    	        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
    	          expectedTypes.push(checkerResult.data.expectedType);
    	        }
    	      }
    	      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';
    	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
    	    }
    	    return createChainableTypeChecker(validate);
    	  }

    	  function createNodeChecker() {
    	    function validate(props, propName, componentName, location, propFullName) {
    	      if (!isNode(props[propName])) {
    	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
    	      }
    	      return null;
    	    }
    	    return createChainableTypeChecker(validate);
    	  }

    	  function invalidValidatorError(componentName, location, propFullName, key, type) {
    	    return new PropTypeError(
    	      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +
    	      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'
    	    );
    	  }

    	  function createShapeTypeChecker(shapeTypes) {
    	    function validate(props, propName, componentName, location, propFullName) {
    	      var propValue = props[propName];
    	      var propType = getPropType(propValue);
    	      if (propType !== 'object') {
    	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
    	      }
    	      for (var key in shapeTypes) {
    	        var checker = shapeTypes[key];
    	        if (typeof checker !== 'function') {
    	          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
    	        }
    	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
    	        if (error) {
    	          return error;
    	        }
    	      }
    	      return null;
    	    }
    	    return createChainableTypeChecker(validate);
    	  }

    	  function createStrictShapeTypeChecker(shapeTypes) {
    	    function validate(props, propName, componentName, location, propFullName) {
    	      var propValue = props[propName];
    	      var propType = getPropType(propValue);
    	      if (propType !== 'object') {
    	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
    	      }
    	      // We need to check all keys in case some are required but missing from props.
    	      var allKeys = assign({}, props[propName], shapeTypes);
    	      for (var key in allKeys) {
    	        var checker = shapeTypes[key];
    	        if (has(shapeTypes, key) && typeof checker !== 'function') {
    	          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
    	        }
    	        if (!checker) {
    	          return new PropTypeError(
    	            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
    	            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
    	            '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')
    	          );
    	        }
    	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
    	        if (error) {
    	          return error;
    	        }
    	      }
    	      return null;
    	    }

    	    return createChainableTypeChecker(validate);
    	  }

    	  function isNode(propValue) {
    	    switch (typeof propValue) {
    	      case 'number':
    	      case 'string':
    	      case 'undefined':
    	        return true;
    	      case 'boolean':
    	        return !propValue;
    	      case 'object':
    	        if (Array.isArray(propValue)) {
    	          return propValue.every(isNode);
    	        }
    	        if (propValue === null || isValidElement(propValue)) {
    	          return true;
    	        }

    	        var iteratorFn = getIteratorFn(propValue);
    	        if (iteratorFn) {
    	          var iterator = iteratorFn.call(propValue);
    	          var step;
    	          if (iteratorFn !== propValue.entries) {
    	            while (!(step = iterator.next()).done) {
    	              if (!isNode(step.value)) {
    	                return false;
    	              }
    	            }
    	          } else {
    	            // Iterator will provide entry [k,v] tuples rather than values.
    	            while (!(step = iterator.next()).done) {
    	              var entry = step.value;
    	              if (entry) {
    	                if (!isNode(entry[1])) {
    	                  return false;
    	                }
    	              }
    	            }
    	          }
    	        } else {
    	          return false;
    	        }

    	        return true;
    	      default:
    	        return false;
    	    }
    	  }

    	  function isSymbol(propType, propValue) {
    	    // Native Symbol.
    	    if (propType === 'symbol') {
    	      return true;
    	    }

    	    // falsy value can't be a Symbol
    	    if (!propValue) {
    	      return false;
    	    }

    	    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    	    if (propValue['@@toStringTag'] === 'Symbol') {
    	      return true;
    	    }

    	    // Fallback for non-spec compliant Symbols which are polyfilled.
    	    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
    	      return true;
    	    }

    	    return false;
    	  }

    	  // Equivalent of `typeof` but with special handling for array and regexp.
    	  function getPropType(propValue) {
    	    var propType = typeof propValue;
    	    if (Array.isArray(propValue)) {
    	      return 'array';
    	    }
    	    if (propValue instanceof RegExp) {
    	      // Old webkits (at least until Android 4.0) return 'function' rather than
    	      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
    	      // passes PropTypes.object.
    	      return 'object';
    	    }
    	    if (isSymbol(propType, propValue)) {
    	      return 'symbol';
    	    }
    	    return propType;
    	  }

    	  // This handles more types than `getPropType`. Only used for error messages.
    	  // See `createPrimitiveTypeChecker`.
    	  function getPreciseType(propValue) {
    	    if (typeof propValue === 'undefined' || propValue === null) {
    	      return '' + propValue;
    	    }
    	    var propType = getPropType(propValue);
    	    if (propType === 'object') {
    	      if (propValue instanceof Date) {
    	        return 'date';
    	      } else if (propValue instanceof RegExp) {
    	        return 'regexp';
    	      }
    	    }
    	    return propType;
    	  }

    	  // Returns a string that is postfixed to a warning about an invalid type.
    	  // For example, "undefined" or "of type array"
    	  function getPostfixForTypeWarning(value) {
    	    var type = getPreciseType(value);
    	    switch (type) {
    	      case 'array':
    	      case 'object':
    	        return 'an ' + type;
    	      case 'boolean':
    	      case 'date':
    	      case 'regexp':
    	        return 'a ' + type;
    	      default:
    	        return type;
    	    }
    	  }

    	  // Returns class name of the object, if any.
    	  function getClassName(propValue) {
    	    if (!propValue.constructor || !propValue.constructor.name) {
    	      return ANONYMOUS;
    	    }
    	    return propValue.constructor.name;
    	  }

    	  ReactPropTypes.checkPropTypes = checkPropTypes;
    	  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
    	  ReactPropTypes.PropTypes = ReactPropTypes;

    	  return ReactPropTypes;
    	};
    	return factoryWithTypeCheckers;
    }

    /**
     * Copyright (c) 2013-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var factoryWithThrowingShims;
    var hasRequiredFactoryWithThrowingShims;

    function requireFactoryWithThrowingShims () {
    	if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
    	hasRequiredFactoryWithThrowingShims = 1;

    	var ReactPropTypesSecret = requireReactPropTypesSecret();

    	function emptyFunction() {}
    	function emptyFunctionWithReset() {}
    	emptyFunctionWithReset.resetWarningCache = emptyFunction;

    	factoryWithThrowingShims = function() {
    	  function shim(props, propName, componentName, location, propFullName, secret) {
    	    if (secret === ReactPropTypesSecret) {
    	      // It is still safe when called from React.
    	      return;
    	    }
    	    var err = new Error(
    	      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
    	      'Use PropTypes.checkPropTypes() to call them. ' +
    	      'Read more at http://fb.me/use-check-prop-types'
    	    );
    	    err.name = 'Invariant Violation';
    	    throw err;
    	  }	  shim.isRequired = shim;
    	  function getShim() {
    	    return shim;
    	  }	  // Important!
    	  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
    	  var ReactPropTypes = {
    	    array: shim,
    	    bigint: shim,
    	    bool: shim,
    	    func: shim,
    	    number: shim,
    	    object: shim,
    	    string: shim,
    	    symbol: shim,

    	    any: shim,
    	    arrayOf: getShim,
    	    element: shim,
    	    elementType: shim,
    	    instanceOf: getShim,
    	    node: shim,
    	    objectOf: getShim,
    	    oneOf: getShim,
    	    oneOfType: getShim,
    	    shape: getShim,
    	    exact: getShim,

    	    checkPropTypes: emptyFunctionWithReset,
    	    resetWarningCache: emptyFunction
    	  };

    	  ReactPropTypes.PropTypes = ReactPropTypes;

    	  return ReactPropTypes;
    	};
    	return factoryWithThrowingShims;
    }

    /**
     * Copyright (c) 2013-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredPropTypes;

    function requirePropTypes () {
    	if (hasRequiredPropTypes) return propTypes.exports;
    	hasRequiredPropTypes = 1;
    	if (process.env.NODE_ENV !== 'production') {
    	  var ReactIs = requireReactIs();

    	  // By explicitly using `prop-types` you are opting into new development behavior.
    	  // http://fb.me/prop-types-in-prod
    	  var throwOnDirectAccess = true;
    	  propTypes.exports = requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    	} else {
    	  // By explicitly using `prop-types` you are opting into new production behavior.
    	  // http://fb.me/prop-types-in-prod
    	  propTypes.exports = requireFactoryWithThrowingShims()();
    	}
    	return propTypes.exports;
    }

    var Icon=function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n});},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0});},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)r.d(n,o,function(t){return e[t]}.bind(null,o));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=2)}([function(e,t){e.exports=requirePropTypes();},function(e,t){e.exports=React;},function(e,t,r){r.r(t);var n=r(1),o=r(0),l=function(){return (l=Object.assign||function(e){for(var t,r=1,n=arguments.length;r<n;r++)for(var o in t=arguments[r])Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o]);return e}).apply(this,arguments)},i=function(e,t){var r={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.indexOf(n)<0&&(r[n]=e[n]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var o=0;for(n=Object.getOwnPropertySymbols(e);o<n.length;o++)t.indexOf(n[o])<0&&Object.prototype.propertyIsEnumerable.call(e,n[o])&&(r[n[o]]=e[n[o]]);}return r},a=0,s=n.forwardRef((function(e,t){var r=e.title,o=void 0===r?null:r,s=e.description,c=void 0===s?null:s,u=e.size,p=void 0===u?null:u,f=e.color,d=void 0===f?"currentColor":f,y=e.horizontal,v=void 0===y?null:y,b=e.vertical,m=void 0===b?null:b,h=e.rotate,g=void 0===h?null:h,O=e.spin,w=void 0===O?null:O,j=e.style,z=void 0===j?{}:j,E=e.children,P=i(e,["title","description","size","color","horizontal","vertical","rotate","spin","style","children"]);a++;var S,x=null!==w&&w,_=n.Children.map(E,(function(e){var t=e;!0!==x&&(x=!0===(null===w?t.props.spin:w));var r=t.props.size;"number"==typeof p&&"number"==typeof t.props.size&&(r=t.props.size/p);var o={size:r,color:null===d?t.props.color:d,horizontal:null===v?t.props.horizontal:v,vertical:null===m?t.props.vertical:m,rotate:null===g?t.props.rotate:g,spin:null===w?t.props.spin:w,inStack:!0};return n.cloneElement(t,o)}));null!==p&&(z.width="string"==typeof p?p:1.5*p+"rem");var k,T="stack_labelledby_"+a,q="stack_describedby_"+a;if(o)S=c?T+" "+q:T;else if(k="presentation",c)throw new Error("title attribute required when description is set");return n.createElement("svg",l({ref:t,viewBox:"0 0 24 24",style:z,role:k,"aria-labelledby":S},P),o&&n.createElement("title",{id:T},o),c&&n.createElement("desc",{id:q},c),x&&n.createElement("style",null,"@keyframes spin { from { transform: rotate(0deg) } to { transform: rotate(360deg) } }","@keyframes spin-inverse { from { transform: rotate(0deg) } to { transform: rotate(-360deg) } }"),_)}));s.displayName="Stack",s.propTypes={size:o.oneOfType([o.number,o.string]),color:o.string,horizontal:o.bool,vertical:o.bool,rotate:o.number,spin:o.oneOfType([o.bool,o.number]),children:o.oneOfType([o.arrayOf(o.node),o.node]).isRequired,className:o.string,style:o.object},s.defaultProps={size:null,color:null,horizontal:null,vertical:null,rotate:null,spin:null};var c=s;r.d(t,"Icon",(function(){return d})),r.d(t,"Stack",(function(){return c}));var u=function(){return (u=Object.assign||function(e){for(var t,r=1,n=arguments.length;r<n;r++)for(var o in t=arguments[r])Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o]);return e}).apply(this,arguments)},p=function(e,t){var r={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.indexOf(n)<0&&(r[n]=e[n]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var o=0;for(n=Object.getOwnPropertySymbols(e);o<n.length;o++)t.indexOf(n[o])<0&&Object.prototype.propertyIsEnumerable.call(e,n[o])&&(r[n[o]]=e[n[o]]);}return r},f=0,d=n.forwardRef((function(e,t){var r=e.path,o=e.id,l=void 0===o?++f:o,i=e.title,a=void 0===i?null:i,s=e.description,c=void 0===s?null:s,d=e.size,y=void 0===d?null:d,v=e.color,b=void 0===v?"currentColor":v,m=e.horizontal,h=void 0!==m&&m,g=e.vertical,O=void 0!==g&&g,w=e.rotate,j=void 0===w?0:w,z=e.spin,E=void 0!==z&&z,P=e.style,S=void 0===P?{}:P,x=e.inStack,_=void 0!==x&&x,k=p(e,["path","id","title","description","size","color","horizontal","vertical","rotate","spin","style","inStack"]),T={},q=[];null!==y&&(_?q.push("scale("+y+")"):(S.width="string"==typeof y?y:1.5*y+"rem",S.height=S.width)),h&&q.push("scaleX(-1)"),O&&q.push("scaleY(-1)"),0!==j&&q.push("rotate("+j+"deg)"),null!==b&&(T.fill=b);var M=n.createElement("path",u({d:r,style:T},_?k:{})),C=M;q.length>0&&(S.transform=q.join(" "),S.transformOrigin="center",_&&(C=n.createElement("g",{style:S},M,n.createElement("rect",{width:"24",height:"24",fill:"transparent"}))));var I,N=C,R=!0===E||"number"!=typeof E?2:E,B=!_&&(h||O);if(R<0&&(B=!B),E&&(N=n.createElement("g",{style:{animation:"spin"+(B?"-inverse":"")+" linear "+Math.abs(R)+"s infinite",transformOrigin:"center"}},C,!(h||O||0!==j)&&n.createElement("rect",{width:"24",height:"24",fill:"transparent"}))),_)return N;var X,Y="icon_labelledby_"+l,A="icon_describedby_"+l;if(a)I=c?Y+" "+A:Y;else if(X="presentation",c)throw new Error("title attribute required when description is set");return n.createElement("svg",u({ref:t,viewBox:"0 0 24 24",style:S,role:X,"aria-labelledby":I},k),a&&n.createElement("title",{id:Y},a),c&&n.createElement("desc",{id:A},c),!_&&E&&(B?n.createElement("style",null,"@keyframes spin-inverse { from { transform: rotate(0deg) } to { transform: rotate(-360deg) } }"):n.createElement("style",null,"@keyframes spin { from { transform: rotate(0deg) } to { transform: rotate(360deg) } }")),N)}));d.displayName="Icon",d.propTypes={path:o.string.isRequired,size:o.oneOfType([o.number,o.string]),color:o.string,horizontal:o.bool,vertical:o.bool,rotate:o.number,spin:o.oneOfType([o.bool,o.number]),style:o.object,inStack:o.bool,className:o.string},d.defaultProps={size:null,color:"currentColor",horizontal:!1,vertical:!1,rotate:0,spin:!1};t.default=d;}]);


    var Icon$1 = /*@__PURE__*/getDefaultExportFromCjs(Icon);

    const Button = (props) => {
        const { scheme } = useTheme();
        const { type = "filled", icon } = props, buttonProps = __rest(props, ["type", "icon"]);
        const background = type === "filled"
            ? hexFromArgb(scheme["primary"])
            : type === "tonal"
                ? hexFromArgb(scheme["secondaryContainer"])
                : "transparent";
        const onbackground = type === "filled"
            ? hexFromArgb(scheme["onPrimary"])
            : type === "tonal"
                ? hexFromArgb(scheme["onSecondaryContainer"])
                : hexFromArgb(scheme["primary"]);
        const StateLayerStyle = css `
		padding: 0px 24px;
		transition: background-color 300ms;
		display: flex;
		align-items: center;
		justify-content: center;
		gap: 8px;
		${icon && "padding-left: 16px;"}
		color: ${onbackground}${props.disabled &&
        Math.round(0.38 * 256 * 1)
            .toString(16)
            .padStart(2, "0")};
		
		button:not(:disabled):hover & {
			background-color: ${onbackground +
        Math.round(0.08 * 256)
            .toString(16)
            .padStart(2, "0")};
		}
		button:not(:disabled):active & {
			background-color: ${onbackground +
        Math.round(0.12 * 256)
            .toString(16)
            .padStart(2, "0")};
		}
		button:not(:disabled):focus-visible & {
			background-color: ${onbackground +
        Math.round(0.12 * 256)
            .toString(16)
            .padStart(2, "0")};
		}
		${textStylesForType("labelLarge")}
	`;
        return (React.createElement("button", Object.assign({ className: css `
				all: unset;
				cursor: ${!props.disabled && 'pointer'};
				overflow: hidden;
				width: fit-content;
				height: 36px;
				display: flex;
				border-radius: 999px;
				background-color: ${background}${props.disabled &&
            Math.round(0.38 * 256)
                .toString(16)
                .padStart(2, "0")};
				${type === "outline" &&
            `border: ${hexFromArgb(scheme.outline)}${props.disabled ?
                Math.round(0.38 * 256)
                    .toString(16)
                    .padStart(2, "0")
                : ''} 1px solid `}
			` }, buttonProps),
            React.createElement("div", { className: StateLayerStyle },
                icon && React.createElement(Icon$1, { path: icon, size: "18px" }),
                props.children)));
    };

    const typographySet = {
        displayLarge: {
            lineHeight: 64,
            fontSize: 57,
            letterSpacing: -0.25,
            fontWeight: 400,
        },
        displayMedium: {
            lineHeight: 52,
            fontSize: 45,
            letterSpacing: 0,
            fontWeight: 400,
        },
        displaySmall: {
            lineHeight: 44,
            fontSize: 36,
            letterSpacing: 0,
            fontWeight: 400,
        },
        headlineLarge: {
            lineHeight: 44,
            fontSize: 36,
            letterSpacing: 0,
            fontWeight: 400,
        },
        headlineMedium: {
            lineHeight: 36,
            fontSize: 28,
            letterSpacing: 0,
            fontWeight: 400,
        },
        headlineSmall: {
            lineHeight: 32,
            fontSize: 24,
            letterSpacing: 0,
            fontWeight: 400,
        },
        titleLarge: {
            lineHeight: 28,
            fontSize: 22,
            letterSpacing: 0,
            fontWeight: 400,
        },
        titleMedium: {
            lineHeight: 24,
            fontSize: 16,
            letterSpacing: 0.15,
            fontWeight: 500,
        },
        titleSmall: {
            lineHeight: 20,
            fontSize: 14,
            letterSpacing: 0.1,
            fontWeight: 500,
        },
        labelLarge: {
            lineHeight: 20,
            fontSize: 14,
            letterSpacing: 0.1,
            fontWeight: 500,
        },
        labelMedium: {
            lineHeight: 16,
            fontSize: 12,
            letterSpacing: 0.5,
            fontWeight: 500,
        },
        labelSmall: {
            lineHeight: 16,
            fontSize: 11,
            letterSpacing: 0.5,
            fontWeight: 500,
        },
        bodyLarge: {
            lineHeight: 24,
            fontSize: 16,
            letterSpacing: 0.5,
            fontWeight: 400,
        },
        bodyMedium: {
            lineHeight: 20,
            fontSize: 14,
            letterSpacing: 0.25,
            fontWeight: 400,
        },
        bodySmall: {
            lineHeight: 16,
            fontSize: 12,
            letterSpacing: 0.4,
            fontWeight: 400,
        },
    };
    function textStylesForType(type) {
        const thisTextTypography = typographySet[type];
        return `
  line-height: ${thisTextTypography.lineHeight}px;
  font-size: ${thisTextTypography.fontSize + 2}px;
  letter-spacing: ${thisTextTypography.letterSpacing}px;
  font-weight: ${thisTextTypography.fontWeight};`;
    }
    const Text = (_a) => {
        var props = __rest(_a, []);
        const { color, type, children } = props, spanProps = __rest(props, ["color", "type", "children"]);
        const { scheme } = useTheme();
        const thisTextTypography = typographySet[type || "bodyMedium"];
        return (React.createElement(React.Fragment, null,
            React.createElement("span", Object.assign({ className: css `
					//color: #${scheme[color || "onBackground"].toString(16).slice(0, -2)};
					color: ${hexFromArgb(scheme[color || "onBackground"])};
					line-height: ${thisTextTypography.lineHeight}px;
					font-size: ${thisTextTypography.fontSize}px;
					letter-spacing: ${thisTextTypography.letterSpacing}px;
					font-weight: ${thisTextTypography.fontWeight};
				` }, spanProps), children)));
    };

    const NavigationBarSegment = (props) => {
        const { scheme } = useTheme();
        const onbackground = props.activated
            ? hexFromArgb(scheme["onPrimaryContainer"])
            : hexFromArgb(scheme["onPrimaryContainer"]);
        return (React.createElement("div", { tabIndex: 1, className: css `
				display: flex;
				flex-direction: column;
				gap: 4px;
				align-items: center;
				& div,
				span {
					transition: background-color 300ms ease-in-out, color 300ms ease-in-out;
				}
                &:focus-visible {
                    outline: unset;
                }
                
			`, onClick: props.onClick, onKeyDown: (e) => {
                if (e.key === "Enter" && props.onClick)
                    props.onClick(e);
            } },
            React.createElement("div", { className: css `
					display: flex;
					justify-content: center;
					align-items: center;
					border-radius: 99px;
					width: ${props.horizontal ? "56px" : "64px"};
					height: 32px;
					background-color: ${props.activated && hexFromArgb(scheme.secondaryContainer)};
					color: ${props.activated
                ? hexFromArgb(scheme.onSurface)
                : hexFromArgb(scheme.onSurfaceVariant)};
					div:hover > & {
						background-color: ${onbackground +
                Math.round(0.08 * 256)
                    .toString(16)
                    .padStart(2, "0")};
					}
					div:active > & {
						background-color: ${onbackground +
                Math.round(0.12 * 256)
                    .toString(16)
                    .padStart(2, "0")};
					}
					div:focus-visible > & {
						background-color: ${onbackground +
                Math.round(0.12 * 256)
                    .toString(16)
                    .padStart(2, "0")};
					}
				` }, props.icon && props.activated ? (React.createElement(Icon$1, { size: "24px", path: props.icon })) : props.inActiveIcon && !props.activated ? (React.createElement(Icon$1, { size: "24px", path: props.inActiveIcon })) : (props.icon && React.createElement(Icon$1, { size: "24px", path: props.icon }))),
            React.createElement(Text, { style: { textAlign: "center" }, type: "labelMedium", color: props.activated ? "onSurface" : "onSurfaceVariant" }, props.label)));
    };
    const NavigationBar = (props) => {
        const { scheme } = useTheme();
        const [activeIndex, setActiveIndex] = React.useState(0);
        const { horizontal, segments, handleSelected } = props, navigationbarProps = __rest(props, ["horizontal", "segments", "handleSelected"]);
        return (React.createElement("nav", Object.assign({ className: css `
				display: flex;
				flex-direction: ${props.horizontal ? "column" : "row"};
				gap: 16px;
				background-color: ${hexFromArgb(scheme.surfaceContainer)};
				width: max-content;
                ${!horizontal && "justify-content: space-evenly;"};
				padding-top: 12px;
				padding-bottom: 16px;
				${!horizontal && "width: 100%;"};
				${horizontal && "width: 80px;"};
			` }, navigationbarProps), props.segments.map((segment, i) => {
            return (React.createElement(NavigationBarSegment, Object.assign({}, segment, { title: activeIndex === i ? "tak" : "nie", activated: activeIndex === i, key: i, horizontal: props.horizontal, onClick: () => {
                    setActiveIndex(i);
                    if (props.handleSelected) {
                        props.handleSelected(i);
                    }
                } })));
        })));
    };

    function LayoutWithNavigationBar(props) {
        const { updateSourceColor, scheme, toggleMode } = useTheme();
        const [selected, setSelected] = React.useState(0);
        const [isCompact, setIsCompact] = React.useState(window.matchMedia("(max-width: 600px)").matches);
        const handler = (e) => setIsCompact(e.matches);
        window.matchMedia("(max-width: 600px)").addEventListener("change", handler);
        let children = [];
        if (Array.isArray(props.children)) {
            children = props.children;
        }
        else {
            children = [props.children];
        }
        return (React.createElement("div", { className: css `
				background-color: ${hexFromArgb(scheme.background)};
				flex: 1;
				display: flex;
				flex-direction: ${isCompact ? "column-reverse" : "row"};
				width: 100%;
				height: 100%;
				color: ${hexFromArgb(scheme.onBackground)};
			` },
            React.createElement(NavigationBar, { handleSelected: (i) => { setSelected(i); }, horizontal: isCompact ? false : true, segments: props.segments }),
            React.createElement("main", { className: css `flex: 1; display: flex; background-color: ${hexFromArgb(scheme.background)}; overflow: auto;` }, children[selected])));
    }

    exports.Button = Button;
    exports.ColorSurface = ColorSurface;
    exports.InteractiveStateLayer = InteractiveStateLayer;
    exports.LayoutWithNavigationBar = LayoutWithNavigationBar;
    exports.NavigationBar = NavigationBar;
    exports.Text = Text;
    exports.ThemeProvider = ThemeProvider;
    exports.textStylesForType = textStylesForType;
    exports.useTheme = useTheme;

}));
